üèóÔ∏è Arquitectura General y MicrocontroladoresEl sistema utiliza una arquitectura de control distribuido con dos procesadores1:Consola (Maestro) - "Puente de Mando":Hardware: M√≥dulo ESP32-P4 con pantalla t√°ctil integrada de 10.1 pulgadas2222.Ubicaci√≥n: Panel de control del usuario.Rol: Gestiona la interfaz de usuario (UI), el estado del entrenamiento y act√∫a como Maestro en el bus de comunicaci√≥n.Sala de M√°quinas (Esclavo) - "Jefe de M√°quinas":Hardware: Placa de desarrollo ESP32 DevKitC333.Ubicaci√≥n: Base de la cinta de correr4.Rol: Controla todo el hardware de potencia (VFD, rel√©s) y lee los sensores (velocidad, fin de carrera)5. Act√∫a como Esclavo en el bus de comunicaci√≥n.2. üîå Conexi√≥n Maestro-Esclavo (Consola $\leftrightarrow$ Sala de M√°quinas)La comunicaci√≥n entre las dos placas ESP32 es el enlace de control principal.Medio F√≠sico: Bus serie RS485 half-duplex666. Se seleccion√≥ por su alta inmunidad al ruido electromagn√©tico (EMI) generado por el VFD7.Protocolo: CM_Protocol v2.1 (definido en la secci√≥n 4).Conexiones de Pines (Sala de M√°quinas):Puerto UART: UART_NUM_18.Pin TX (Transmisi√≥n): GPIO 179999999.Pin RX (Recepci√≥n): GPIO 1610101010101010.Nota: Se asume un transceptor RS485 externo (ej. MAX485) conectado a estos pines.3. ‚öôÔ∏è Conexiones de Hardware (Sala de M√°quinas)El ESP32 Esclavo gestiona todas las entradas/salidas de hardware de la cinta.Nota: La asignaci√≥n de pines se basa en los documentos finales del proyecto (RESUMEN FINAL 11y SALA MAQUINAS continuar.txt 12), que corrigen la asignaci√≥n "v5" m√°s antigua que figura en el archivo main.c13.Control del Motor Principal (VFD)Hardware: Variador de Frecuencia (VFD) SU3001414.Medio F√≠sico: Bus RS485 dedicado (Protocolo Modbus RTU)1515.Conexiones de Pines (Sala de M√°quinas):Puerto UART: UART_NUM_2161616.Pin TX (Transmisi√≥n): GPIO 1917.Pin RX (Recepci√≥n): GPIO 1818.Pin DE/RE (Control de direcci√≥n): No se usa; el hardware implementa conmutaci√≥n autom√°tica (seg√∫n su informaci√≥n previa).Sensores (Entradas)Funci√≥nPin (ESP32)Tipo de HardwareSensor de VelocidadGPIO 34 [cite: 3, 48, 2949]Sensor Hall (PCNT) [cite: 2949]Fin de CarreraGPIO 35 [cite: 3, 48, 2950]Switch (Homing Inclinaci√≥n) [cite: 2950]Actuadores (Salidas a Rel√©s)Funci√≥nPin (ESP32)Hardware ControladoInclinaci√≥n SUBIRGPIO 25 [cite: 3, 2955]Rel√© 1 (Actuador lineal)Inclinaci√≥n BAJARGPIO 26 [cite: 3, 2955]Rel√© 2 (Actuador lineal)Bomba de CeraGPIO 32 [cite: 3, 2952]Rel√© 3 (Bomba 115V) [cite: 108]Ventilador Pecho (ON/OFF)GPIO 12 [cite: 3, 2954]Rel√© 4 (Potencia)Ventilador Pecho (SPEED)GPIO 13 [cite: 3, 2954]Rel√© 5 (Selecci√≥n)Ventilador Cabeza (ON/OFF)GPIO 14 [cite: 3, 2953]Rel√© 6 (Potencia)Ventilador Cabeza (SPEED)GPIO 27 [cite: 3, 2953]Rel√© 7 (Selecci√≥n)4. üß† L√≥gica de Protocolo (CM_Protocol v2.1)El sistema opera bajo un modelo at√≥mico (cada comando hace una sola cosa) para asegurar la robustez.L√≥gica del Maestro (Consola)La Consola implementa una tarea de heartbeat (cm_master_task) que gestiona un sondeo (polling) priorizado:Prioridad 1 (Acci√≥n de Usuario):Al pulsar un bot√≥n (ej. "+ VEL"), la UI no env√≠a el comando. Solo actualiza una variable de estado global (g_target_speed).La cm_master_task detecta este cambio y env√≠a un solo comando SET (ej. CM_CMD_SET_SPEED).Un flag (g_waiting_for_speed_ack) previene que se env√≠en m√°s comandos SET del mismo tipo hasta que se reciba el ACK correspondiente, evitando la saturaci√≥n de la cola (Pending queue full!).Prioridad 2 (Sondeo de Fondo):Si el bus est√° ocupado (esperando un ACK de un comando SET), el polling se reduce al m√≠nimo cr√≠tico:CM_CMD_GET_STATUS (0x22): Para monitorizar fallos del VFD 19191919.Si el bus est√° libre, se ejecuta el sondeo completo para sincronizar la UI:CM_CMD_GET_STATUS (0x22) (Fallo VFD)CM_CMD_GET_SENSOR_SPEED (0x21) (Velocidad) 20202020CM_CMD_GET_INCLINE_POSITION (0x23) (Inclinaci√≥n) 21212121CM_CMD_GET_FAN_STATE (0x24) (Ventiladores)L√≥gica del Esclavo (Sala de M√°quinas)El Esclavo es puramente reactivo 22222222:Escucha: La uart_rx_task 23232323parsea las tramas entrantes, validando SOF, stuffing y CRC-16 2424242424242424.Responde a SET: Al recibir un comando de acci√≥n (ej. CM_CMD_SET_FAN_STATE 25252525), ejecuta la acci√≥n (ej. gpio_set_level()) y responde con un ACK (0x80) 26262626.Responde a GET: Al recibir un comando de sondeo (ej. CM_CMD_GET_FAN_STATE), ejecuta la funci√≥n de env√≠o (ej. send_fan_state()) y responde con el payload de datos solicitado (ej. RSP_FAN_STATE (0xA4)).Responde a Fallos: Si un comando falla (ej. VFD en fallo al intentar SET_SPEED 27272727) o es desconocido, responde con un NAK (0x81) 28282828 y el c√≥digo de error espec√≠fico (ej. CM_ERR_VFD_FAULT (0xE6)).5. üìã Listado Completo de Comandos (CM_Protocol v2.1)TipoComandoC√≥digoDirecci√≥nPayload Enviado (Maestro)Respuesta (Esclavo)Payload Recibido (Maestro)Acci√≥nSET_SPEED0x11M $\to$ S2 bytes (Velocidad km/h * 100)ACK (0x80) / NAK (0x81)N/AAcci√≥nSET_INCLINE0x12M $\to$ S2 bytes (Inclinaci√≥n % * 10)ACK (0x80) / NAK (0x81)N/AAcci√≥nSET_FAN_STATE0x14M $\to$ S2 bytes (ID Ventilador, Estado 0-2)ACK (0x80) / NAK (0x81)N/AAcci√≥nSET_RELAY0x13M $\to$ S2 bytes (ID Rel√©, Estado 0-1)ACK (0x80) / NAK (0x81)N/AAcci√≥nCALIBRATE_INCLINE0x15M $\to$ S0 bytesACK (0x80) / NAK (0x81)N/AAcci√≥nEMERGENCY_STOP0x1FM $\to$ S0 bytesACK (0x80)N/ASondeoGET_STATUS0x22M $\to$ S0 bytesRSP_STATUS (0xA2)1 byte (Bitmap de estado/fallo)SondeoGET_SENSOR_SPEED0x21M $\to$ S0 bytesRSP_SENSOR_SPEED (0xA1)2 bytes (Velocidad km/h * 100)SondeoGET_INCLINE_POSITION0x23M $\to$ S0 bytesRSP_INCLINE_POSITION (0xA3)2 bytes (Inclinaci√≥n % * 10)SondeoGET_FAN_STATE0x24M $\to$ S0 bytesRSP_FAN_STATE (0xA4)