================================================================================
                    DOCUMENTACIÓN COMPLETA DEL PROYECTO
                          CONSOLA_CINTA - TROTADORA
================================================================================

Fecha de generación: 2025-10-17
Versión del proyecto: 1.0
Framework: ESP-IDF 5.4.0
Ubicación: c:\esp\Consola_Cinta\

================================================================================
ÍNDICE
================================================================================

1. DESCRIPCIÓN GENERAL DEL PROYECTO
2. ARQUITECTURA DE HARDWARE
3. ESTRUCTURA DEL PROYECTO
4. MÓDULOS DE SOFTWARE
   4.1. Módulo Principal (main.c)
   4.2. Interfaz de Usuario (ui.c/ui.h)
   4.3. Máquina de Estados (treadmill_state.c/h)
   4.4. Sistema de Audio (audio.c/h)
   4.5. Gestor de Botones (button_handler.c/h)
   4.6. Drivers de Display (display_driver.c/h)
   4.7. Drivers de Touch (touch_driver.c/h)
5. INTEGRACIÓN ESP32-C6 (WiFi y Bluetooth)
6. CONFIGURACIÓN Y COMPILACIÓN
7. PARTICIONES DE MEMORIA
8. DEPENDENCIAS Y COMPONENTES
9. TAREAS Y SINCRONIZACIÓN
10. FLUJO DE EJECUCIÓN
11. NOTAS DE DESARROLLO

================================================================================
1. DESCRIPCIÓN GENERAL DEL PROYECTO
================================================================================

Proyecto de control para una trotadora (cinta de correr) inteligente con
pantalla táctil de 10.1 pulgadas, basado en el módulo JC8012P4A1C_I_W de
Shenzhen Jingcai Intelligent Co., Ltd.

El sistema implementa:
- Interfaz gráfica de usuario (LVGL v8.4) con dos pantallas principales
- Control de velocidad (0-19.5 km/h) con rampa progresiva
- Control de inclinación (0-15%) con rampa en modo cooldown
- Sistema de pausa/reanudación con memoria de velocidad
- Modo enfriamiento (cooldown) con reducción gradual
- Audio de retroalimentación mediante beeps
- Control por 10 botones físicos y pantalla táctil
- Monitoreo de datos: tiempo, distancia, pulso, calorías

Estadísticas del código:
- Total de líneas: ~1,465 líneas de código
- Archivos fuente (.c): 7 archivos
- Archivos de cabecera (.h): 6 archivos
- Fuentes personalizadas: 3 archivos (Chivo Mono 70pt, 100pt, DejaVu Mono 50pt)

================================================================================
2. ARQUITECTURA DE HARDWARE
================================================================================

2.1. ESPECIFICACIONES DE LA PLACA JC8012P4A1C_I_W
--------------------------------------------------

CPU Principal:
  - Modelo: ESP32-P4 (U4)
  - Arquitectura: RISC-V dual-core
  - Frecuencia: 400 MHz (configurado a 360 MHz)
  - SRAM: 768 KB HP L2MEM, 32 KB LP SRAM
  - ROM: 128 KB HP ROM

CPU de Conectividad:
  - Modelo: ESP32-C6 (U7)
  - Función: WiFi y Bluetooth
  - Comunicación con P4: SDIO
  - Pines: SD2_CLK, SD2_CMD, SD2_D0-D3

Memoria:
  - PSRAM: 32 MB @ 200MHz XIP (U5)
  - Flash: 16 MB QIO (U6)

Pantalla:
  - Tamaño: 10.1 pulgadas
  - Resolución: 800 x 1280 píxeles
  - Tipo: TFT IPS
  - Interfaz: MIPI-DSI
  - Chip controlador: JD9365
  - Colores: 16.7 millones (RGB 24-bit)
  - Retroiluminación: Driver MP3202 (IC1)

Panel Táctil:
  - Tipo: Capacitivo
  - Controlador: GSL3680
  - Interfaz: I2C
  - Pines: RTC_CLK/SCL, RTC_DAT/SDA, TOUCH_RST (GPIO45), TOUCH_INT (GPIO46)

Audio:
  - CODEC: ES8311 (U10)
  - Amplificador: NS4150 (U11)
  - Interfaz digital: I2S
  - Interfaz de control: I2C
  - Micrófono: Entrada analógica ADC_MIC1_P/N
  - Altavoz: Salida amplificada

Botones:
  - Chip expansor: MCP23017 (dirección I2C 0x20)
  - Cantidad: 10 botones físicos
  - Pines: GPIO A y GPIO B (16 bits total)

Almacenamiento:
  - Ranura TF (MicroSD): Interfaz SDIO1
  - Detección de tarjeta: GPIO29 (SD_DET)

RTC (Reloj en Tiempo Real):
  - Chip: RX8025T-UC (U8)
  - Batería de respaldo: CR1220
  - Interfaz: I2C compartido
  - Cristal: 32.768 kHz (Y2)

Alimentación:
  - Entrada: 5V USB-C o batería
  - Regulador 3.3V: TLV62569 (U2) desde VOUT-BAT
  - Regulador 1.2V: TLV62569 (U3) para ESP_VDD_HP
  - Gestión de carga: IP5306 (U1)
  - Consumo típico: 700mA @ 5V

Interfaces de Programación:
  - USB-TTL: CH340C (U14), puerto principal para flasheo
  - USB High-Speed: Conectado al ESP32-P4
  - USB Full-Speed: Conectado al ESP32-P4

2.2. MAPA DE PINES CRÍTICOS (ESP32-P4)
---------------------------------------

Display MIPI-DSI:
  - DSI_A_DATA_P/N, DSI_A_CLK_P/N
  - LCD_RST: GPIO48
  - LCD_PWM: GPIO47 (control de brillo)

Touch (I2C):
  - SCL: RTC_CLK (GPIO compartido con RTC)
  - SDA: RTC_DAT (GPIO compartido con RTC)
  - RST: GPIO45
  - INT: GPIO46

Audio I2S:
  - MCLK: GPIO13
  - SCLK: GPIO12
  - LRCK: GPIO10
  - DOUT: GPIO11 (ESP32 → CODEC)
  - DIN: GPIO9 (CODEC → ESP32)

Audio I2C (Control):
  - SCL: RTC_CLK (compartido)
  - SDA: RTC_DAT (compartido)

Botones (I2C):
  - SCL: GPIO7
  - SDA: GPIO8
  - Dirección: 0x20

MicroSD (SDIO1):
  - CLK: SD1_CLK
  - CMD: SD1_CMD
  - DATA: SD1_D0 a SD1_D3
  - DET: GPIO29

Comunicación ESP32-C6 (SDIO2):
  - CLK: SD2_CLK
  - CMD: SD2_CMD
  - DATA: SD2_D0 a SD2_D3

UART Principal (Programación):
  - TXD: GPIO43
  - RXD: GPIO44

2.3. DIAGRAMA DE BLOQUES DEL SISTEMA
-------------------------------------

┌──────────────────────────────────────────────────────────────┐
│                      PLACA JC8012P4A1C_I_W                   │
├──────────────────────────────────────────────────────────────┤
│                                                              │
│  ┌─────────────────┐          ┌──────────────────┐          │
│  │   ESP32-P4      │  SDIO    │    ESP32-C6      │          │
│  │   (U4 - HOST)   │◄────────►│   (U7 - SLAVE)   │          │
│  │                 │          │                  │          │
│  │ Freq: 360MHz    │          │ - WiFi           │          │
│  │ RAM: 768KB      │          │ - BLE            │          │
│  │ PSRAM: 32MB     │          │                  │          │
│  │ Flash: 16MB     │          │                  │          │
│  └────┬────────────┘          └──────────────────┘          │
│       │                                                      │
│       │ MIPI-DSI              I2C (0x20)                     │
│       ├───────────────►┌──────────────┐                     │
│       │                │ MCP23017     │                     │
│       │                │ (Botones x10)│                     │
│       │                └──────────────┘                     │
│       │                                                      │
│       │ I2S + I2C                                            │
│       ├───────────────►┌──────────────┐                     │
│       │                │ ES8311 CODEC │──►NS4150──►Altavoz  │
│       │                │              │◄──Micrófono         │
│       │                └──────────────┘                     │
│       │                                                      │
│       │ I2C                                                  │
│       ├───────────────►┌──────────────┐                     │
│       │                │ GSL3680      │                     │
│  ┌────▼─────────┐      │ (Touch)      │                     │
│  │  Pantalla    │      └──────────────┘                     │
│  │  10.1"       │                                            │
│  │  800x1280    │      ┌──────────────┐                     │
│  │  JD9365      │      │ RX8025T-UC   │                     │
│  └──────────────┘      │ (RTC + CR1220)│                    │
│                        └──────────────┘                     │
│                                                              │
│  Alimentación: 5V → 3.3V (TLV62569) → 1.2V (TLV62569)       │
│                      IP5306 (Gestión de carga)              │
│                                                              │
└──────────────────────────────────────────────────────────────┘

================================================================================
3. ESTRUCTURA DEL PROYECTO
================================================================================

c:\esp\Consola_Cinta\
│
├── Plantilla\                          # Proyecto HOST (ESP32-P4)
│   │
│   ├── main\                           # Código fuente principal
│   │   ├── main.c                      # Entry point (45 líneas)
│   │   ├── ui.c                        # Interfaz gráfica LVGL (851 líneas)
│   │   ├── ui.h                        # Header UI (27 líneas)
│   │   ├── treadmill_state.c           # Estado global (25 líneas)
│   │   ├── treadmill_state.h           # Estructuras de estado (50 líneas)
│   │   ├── audio.c                     # Sistema de audio (78 líneas)
│   │   ├── audio.h                     # Header audio (9 líneas)
│   │   ├── button_handler.c            # Gestor de botones (139 líneas)
│   │   ├── button_handler.h            # Header botones (8 líneas)
│   │   ├── display_driver.c            # Driver de display (121 líneas)
│   │   ├── display_driver.h            # Header display (19 líneas)
│   │   ├── touch_driver.c              # Driver táctil (73 líneas)
│   │   ├── touch_driver.h              # Header touch (20 líneas)
│   │   ├── component.mk                # Makefiles legacy
│   │   ├── CMakeLists.txt              # CMake del componente
│   │   ├── idf_component.yml           # Dependencias gestionadas
│   │   │
│   │   └── fonts\                      # Fuentes personalizadas
│   │       ├── chivo_mono_70.c         # Fuente 70pt (59KB)
│   │       ├── chivo_mono_100.c        # Fuente 100pt (110KB)
│   │       └── dejavu_mono_50.c        # Fuente 50pt (32KB)
│   │
│   ├── managed_components\             # Componentes descargados automáticamente
│   │   ├── lvgl__lvgl\                 # LVGL 8.4.x
│   │   ├── espressif__esp_lvgl_port\   # Puerto LVGL para ESP32
│   │   ├── espressif__esp_codec_dev\   # Framework de codec de audio
│   │   ├── espressif__esp_lcd_touch\   # Framework LCD touch
│   │   ├── espressif__esp_lcd_ek79007\ # Driver LCD EK79007
│   │   ├── espressif__esp_lcd_ili9881c\# Driver LCD ILI9881C
│   │   ├── espressif__esp_lcd_touch_gt911\ # Driver touch GT911
│   │   ├── espressif__cmake_utilities\ # Utilidades CMake
│   │   ├── chmorgan__esp-audio-player\ # Reproductor de audio
│   │   ├── chmorgan__esp-file-iterator\# Iterador de archivos
│   │   ├── chmorgan__esp-libhelix-mp3\ # Decodificador MP3
│   │   ├── espressif__esp_wifi_remote\ # WiFi remoto (ESP32-C6)
│   │   └── espressif__esp_hosted\      # Framework Host-Slave (ESP32-C6)
│   │
│   ├── components\                     # Componentes locales
│   │   └── espressif__esp_lvgl_port\   # Puerto LVGL personalizado
│   │
│   ├── build\                          # Directorio de compilación (generado)
│   │   ├── bootloader\
│   │   ├── esp-idf\
│   │   ├── config\
│   │   └── *.bin, *.elf               # Binarios compilados
│   │
│   ├── CMakeLists.txt                  # CMake principal del proyecto
│   ├── partitions.csv                  # Tabla de particiones (8MB app, 7MB storage)
│   ├── sdkconfig                       # Configuración actual del SDK (generado)
│   ├── sdkconfig.old                   # Configuración anterior
│   ├── sdkconfig.defaults              # Configuración por defecto
│   ├── README.md                       # Documentación del proyecto
│   └── README_CN.md                    # Documentación en chino
│
├── ESP32C6_Slave\                      # Proyecto SLAVE (ESP32-C6)
│   │
│   ├── main\                           # Código fuente del slave
│   │   ├── app_main.c                  # Entry point del slave
│   │   ├── app_main.h                  # Header principal
│   │   ├── slave_bt.c                  # Controlador Bluetooth HCI
│   │   ├── slave_bt.h                  # Header BT
│   │   ├── slave_control.c             # Control RPC (Remote Procedure Call)
│   │   ├── slave_control.h             # Header control
│   │   ├── sdio_slave_api.c            # Driver SDIO slave
│   │   ├── sdio_slave_api.h            # Header SDIO
│   │   ├── spi_slave_api.c             # Driver SPI slave (alternativo)
│   │   ├── spi_hd_slave_api.c          # Driver SPI half-duplex
│   │   ├── uart_slave_api.c            # Driver UART slave (alternativo)
│   │   ├── interface.h                 # Interfaz de transporte
│   │   ├── protocomm_pserial.c         # Protocolo de comunicación
│   │   ├── protocomm_pserial.h         # Header protocomm
│   │   ├── mempool.c                   # Gestor de memoria
│   │   ├── mempool.h                   # Header mempool
│   │   ├── mempool_ll.c                # Mempool low-level
│   │   ├── mempool_ll.h                # Header mempool LL
│   │   ├── stats.c                     # Estadísticas
│   │   ├── stats.h                     # Header stats
│   │   ├── CMakeLists.txt              # CMake del componente
│   │   ├── Kconfig.projbuild           # Opciones de configuración
│   │   │
│   │   └── common\                     # Archivos comunes
│   │       ├── include\
│   │       └── proto\
│   │           └── esp_hosted_rpc.pb-c.c  # Protobuf generado
│   │
│   ├── CMakeLists.txt                  # CMake principal del slave
│   ├── sdkconfig.defaults              # Config por defecto (ESP32-C6)
│   ├── sdkconfig.defaults.esp32        # Config para ESP32 (si aplica)
│   ├── sdkconfig.defaults.esp32c2      # Config para ESP32-C2
│   ├── sdkconfig.defaults.esp32c3      # Config para ESP32-C3
│   ├── sdkconfig.defaults.esp32c5      # Config para ESP32-C5
│   ├── sdkconfig.defaults.esp32c6      # Config específico C6
│   ├── sdkconfig.defaults.esp32s3      # Config para ESP32-S3
│   ├── partitions.esp32.csv            # Particiones ESP32
│   ├── partitions.esp32c2.csv          # Particiones C2
│   ├── partitions.esp32c5.csv          # Particiones C5
│   ├── partitions.esp32c6.csv          # Particiones C6 (OTA 2x1536KB)
│   └── partitions.esp32s3.csv          # Particiones S3
│
├── common_components\                  # Componentes compartidos
│   │
│   ├── esp32_p4_function_ev_board\     # BSP de la placa
│   │   ├── include\
│   │   │   └── bsp\
│   │   │       ├── esp-bsp.h           # Header principal BSP
│   │   │       ├── display.h           # API de display
│   │   │       ├── touch.h             # API de touch
│   │   │       ├── config.h            # Configuración BSP
│   │   │       └── esp32_p4_function_ev_board.h
│   │   ├── priv_include\
│   │   │   └── bsp_err_check.h         # Macros de error
│   │   ├── CMakeLists.txt
│   │   ├── README.md
│   │   └── LICENSE
│   │
│   ├── bsp_extra\                      # Extensiones BSP
│   │   ├── include\
│   │   │   └── bsp_board_extra.h       # API extendida
│   │   ├── src\
│   │   │   └── bsp_board_extra.c       # Implementación audio/codec
│   │   ├── idf_component.yml
│   │   ├── CMakeLists.txt
│   │   └── LICENSE
│   │
│   ├── esp_lcd_touch_gsl3680\          # Driver touch GSL3680
│   │   ├── include\
│   │   │   └── gsl_point_id.h
│   │   ├── gsl_point_id.c
│   │   ├── idf_component.yml
│   │   └── CMakeLists.txt
│   │
│   ├── esp_lcd_jd9365\                 # Driver LCD JD9365 (10.1")
│   │   ├── include\
│   │   │   └── esp_lcd_jd9365.h
│   │   ├── test_apps\
│   │   ├── idf_component.yml
│   │   ├── CMakeLists.txt
│   │   ├── CHANGELOG.md
│   │   ├── README.md
│   │   └── license.txt
│   │
│   └── espressif__esp_lcd_jd9165\      # Driver LCD JD9165 (alternativo)
│       ├── include\
│       │   └── esp_lcd_jd9165.h
│       ├── esp_lcd_jd9165.c
│       ├── test_apps\
│       ├── idf_component.yml
│       ├── CMakeLists.txt
│       ├── CHANGELOG.md
│       ├── README.md
│       └── license.txt
│
├── README_ESP32C6.md                   # Documentación integración C6
└── documentacion.txt                   # ESTE DOCUMENTO

================================================================================
4. MÓDULOS DE SOFTWARE
================================================================================

4.1. MÓDULO PRINCIPAL (main.c)
-------------------------------

Archivo: c:\esp\Consola_Cinta\Plantilla\main\main.c
Líneas de código: 45

Responsabilidades:
- Entry point del programa (app_main)
- Inicialización de subsistemas
- Creación de tareas principales

Flujo de inicialización:

void app_main(void) {
    1. Crear mutex de sincronización (g_state_mutex)
       - Protege acceso a la estructura global g_treadmill_state
       - Sincronización entre tarea UI y gestor de botones

    2. Inicializar display (bsp_display_start)
       - Configuración MIPI-DSI
       - Inicialización del controlador JD9365
       - Activación de backlight
       - Rotación de pantalla a 270°

    3. Inicializar UI (ui_init)
       - Crear pantallas LVGL
       - Configurar estilos y objetos gráficos
       - Inicializar labels y botones táctiles

    4. Inicializar audio (audio_init)
       - Configurar I2S a 44.1 kHz mono 16-bit
       - Inicializar codec ES8311
       - Generar tabla de onda senoidal para beep de 1 kHz

    5. Inicializar gestor de botones (button_handler_init)
       - Configurar I2C para MCP23017
       - Inicializar pines como entrada con pull-up
       - Crear tarea de polling cada 50ms

    6. Crear tarea de actualización UI (ui_update_task)
       - Prioridad: 5
       - Stack: 4096 bytes
       - Período: 100ms (10 Hz)
}

Observaciones importantes:
- No modifica el código existente para integración ESP32-C6
- El componente esp_hosted se inicializa automáticamente vía constructor
- Sin llamadas explícitas a funciones WiFi/BT en main()

4.2. INTERFAZ DE USUARIO (ui.c/ui.h)
-------------------------------------

Archivo: c:\esp\Consola_Cinta\Plantilla\main\ui.c
Líneas de código: 851 (el módulo más extenso del proyecto)

Componentes gráficos:

A) PANTALLA PRINCIPAL (Main Screen)
------------------------------------
Layout:
  ┌────────────────────────────────────────────────┐
  │  [Distancia: 0.00 km]  [Tiempo: 0:00:00]      │
  │  [Velocidad: 0.0 km/h] [Ritmo: -- min/km]     │
  │  [Pulso: 80 bpm]       [Calorías: 0 kcal]     │
  │                                                │
  │  CLIMB:  [─] [SET] [+]     0.0% (0.0°)        │
  │  SPEED:  [─] [SET] [+]     0.0 km/h           │
  │                                                │
  │  [PAUSE]  [COOLDOWN]                          │
  │                                                │
  │  Info: [Mensaje contextual]                   │
  └────────────────────────────────────────────────┘

Elementos:
- lv_label_distance: Distancia en km o metros
- lv_label_time: Tiempo transcurrido (h:mm:ss)
- lv_label_speed: Velocidad actual con decimales
- lv_label_pace: Ritmo (min/km) calculado
- lv_label_pulse: Pulso simulado (80-175 bpm)
- lv_label_calories: Calorías quemadas
- lv_label_climb_value: Inclinación en % y grados
- lv_label_speed_value: Velocidad grande
- lv_btn_climb_dec/inc/set: Botones de inclinación
- lv_btn_speed_dec/inc/set: Botones de velocidad
- lv_btn_pause: Botón pausa/play
- lv_btn_cooldown: Botón de enfriamiento
- lv_label_info: Mensajes contextuales

B) PANTALLA DE AJUSTE (Set Screen - Numpad)
--------------------------------------------
Layout:
  ┌────────────────────────────────────────────────┐
  │  Ajustando: [VELOCIDAD] o [INCLINACIÓN]       │
  │                                                │
  │  Valor actual:  [D1].[D2][D3]_                │
  │                                                │
  │  ┌───┬───┬───┐                                │
  │  │ 1 │ 2 │ 3 │                                │
  │  ├───┼───┼───┤                                │
  │  │ 4 │ 5 │ 6 │                                │
  │  ├───┼───┼───┤                                │
  │  │ 7 │ 8 │ 9 │                                │
  │  ├───┴───┼───┤                                │
  │  │   0   │CLR│                                │
  │  └───────┴───┘                                │
  │                                                │
  │  [← VOLVER]                                   │
  └────────────────────────────────────────────────┘

Elementos:
- lv_label_numpad_title: Título (VELOCIDAD/INCLINACIÓN)
- lv_label_numpad_value: Muestra valor con cursor parpadeante
- lv_btn_numpad_0 a lv_btn_numpad_9: Botones numéricos
- lv_btn_numpad_clear: Botón de borrar
- lv_btn_numpad_back: Volver a pantalla principal

Funcionamiento del ajuste manual:
1. Usuario presiona SET para velocidad o inclinación
2. Se cambia a pantalla de numpad
3. Usuario ingresa 3 dígitos (ej: "1", "9", "5" → 19.5 km/h)
4. Cursor parpadea cada 500ms indicando posición actual
5. Al completar 3 dígitos, se aplica automáticamente
6. Se valida rango (velocidad: 0-19.5, inclinación: 0-15.0)

Funciones principales:

void ui_init(void)
  - Crea ambas pantallas (main y numpad)
  - Configura estilos (colores, fuentes)
  - Asigna callbacks a eventos táctiles
  - Carga pantalla principal
  - Inicia timer de parpadeo del cursor (500ms)

void ui_update_task(void *pvParameter)
  - Ejecuta cada 100ms (10 Hz)
  - Aplica rampas de velocidad según modo:
    * NORMAL: 5 km/h por segundo
    * PAUSE_STOP: 5 km/h por segundo
    * COOLDOWN_STOP: 10 km/h en 120 segundos (~0.083 km/h/s)
    * RESUME: 5 km/h por segundo
  - Aplica rampa de inclinación en cooldown
  - Calcula tiempo transcurrido (si no está pausado)
  - Calcula distancia: distance += (speed_kmh / 3600.0) * 0.1
  - Simula pulso: 80 + (speed_kmh * 6)
  - Simula calorías según velocidad
  - Actualiza todos los labels LVGL

void ui_speed_inc(void) / ui_speed_dec(void)
  - Incrementa/decrementa en 0.1 km/h
  - Limita entre 0.0 y 19.5 km/h
  - Establece target_speed y activa rampa

void ui_climb_inc(void) / ui_climb_dec(void)
  - Incrementa/decrementa en 0.1%
  - Limita entre 0.0% y 15.0%
  - Aplicación inmediata (sin rampa en modo normal)

void ui_pause_play(void)
  - Si corriendo: pausa y guarda velocidad actual
  - Si pausado: reanuda con rampa a velocidad anterior
  - Cambia etiqueta del botón (PAUSE ↔ PLAY)

void ui_cool_down(void)
  - Activa modo cooldown
  - Rampa lenta de velocidad (120 segundos)
  - Rampa de inclinación a 0% (120 segundos)
  - Deshabilita botones de velocidad

void ui_set_speed(void) / ui_set_climb(void)
  - Cambia a pantalla de numpad
  - Configura modo SET_MODE_SPEED o SET_MODE_CLIMB
  - Resetea buffer de entrada
  - Inicia cursor parpadeante

void ui_handle_numpad_press(int digit)
  - Procesa dígitos 0-9
  - Almacena en buffer (3 posiciones)
  - Avanza cursor
  - Al completar 3 dígitos, llama a ui_confirm_set_value()

void ui_confirm_set_value(void)
  - Convierte buffer a valor decimal (ej: "195" → 19.5)
  - Valida rangos
  - Aplica valor con rampa
  - Vuelve a pantalla principal

Estilos y temas:
- Fondo negro (#000000)
- Texto verde fosforescente (#00FF00)
- Fuente principal: Montserrat 20-44pt
- Fuentes personalizadas: Chivo Mono 70pt y 100pt para valores grandes
- Botones con bordes redondeados
- Indicadores de estado con colores diferenciados

4.3. MÁQUINA DE ESTADOS (treadmill_state.c/h)
----------------------------------------------

Archivo: c:\esp\Consola_Cinta\Plantilla\main\treadmill_state.c (25 líneas)
Header: c:\esp\Consola_Cinta\Plantilla\main\treadmill_state.h (50 líneas)

Estructura principal: TreadmillState

typedef struct {
    // Parámetros operacionales
    float speed_kmh;              // Velocidad actual (0.0-19.5 km/h)
    float climb_percent;          // Inclinación actual (0-15%)
    uint32_t elapsed_seconds;     // Tiempo transcurrido en segundos
    double total_distance_km;     // Distancia total recorrida

    // Estado de control
    bool is_paused;               // true si está en pausa
    bool is_cooling_down;         // true si está en modo cooldown
    bool is_resuming;             // true durante transición de pausa

    // Control de rampa de velocidad
    float speed_before_stop;      // Velocidad antes de parar (para reanudar)
    float target_speed;           // Velocidad objetivo (para rampa)
    float cooldown_climb_ramp_rate; // Tasa de rampa de inclinación en cooldown
    ramp_mode_t ramp_mode;        // Modo actual de rampa

    // Datos simulados (fitness)
    volatile int sim_pulse;       // Pulso simulado en bpm (80-175)
    volatile int sim_kcal;        // Calorías quemadas

    // Modo SET (ajuste manual)
    set_mode_t set_mode;          // SET_MODE_NONE, SPEED o CLIMB
    char set_buffer[4];           // Buffer para dígitos (3 + null terminator)
    int set_digit_index;          // Índice actual (0-2)
    lv_timer_t *blink_timer;      // Timer para parpadeo de cursor
    bool blink_state;             // Estado del parpadeo (visible/invisible)
} TreadmillState;

Modos de rampa (ramp_mode_t):

typedef enum {
    RAMP_MODE_NORMAL,             // Rampa estándar 5 km/h/s
    RAMP_MODE_PAUSE_STOP,         // Parada rápida 5 km/h/s
    RAMP_MODE_COOLDOWN_STOP,      // Enfriamiento lento ~0.083 km/h/s
    RAMP_MODE_PAUSE_RESUME,       // Reanudación 5 km/h/s
    RAMP_MODE_COOLDOWN_RESUME,    // Reanudación desde cooldown
} ramp_mode_t;

Modos de ajuste (set_mode_t):

typedef enum {
    SET_MODE_NONE,                // Pantalla principal activa
    SET_MODE_SPEED,               // Ajustando velocidad
    SET_MODE_CLIMB                // Ajustando inclinación
} set_mode_t;

Variables globales:

TreadmillState g_treadmill_state;    // Estado global del sistema
SemaphoreHandle_t g_state_mutex;    // Mutex para sincronización

Funciones:

void treadmill_state_init(void)
  - Inicializa todos los campos a valores por defecto
  - Velocidad: 0.0 km/h
  - Inclinación: 0.0%
  - Tiempo: 0 segundos
  - Distancia: 0.0 km
  - Pulso inicial: 80 bpm
  - Calorías: 0 kcal
  - Flags: todos en false
  - Modo: RAMP_MODE_NORMAL

Sincronización thread-safe:

// Uso del mutex en código:
xSemaphoreTake(g_state_mutex, portMAX_DELAY);
// Acceso seguro a g_treadmill_state
g_treadmill_state.speed_kmh = new_speed;
xSemaphoreGive(g_state_mutex);

Transiciones de estado:

Estado inicial:
  speed = 0.0, paused = false, cooldown = false

Usuario presiona SPEED +:
  target_speed = speed + 0.1
  ramp_mode = NORMAL
  → ui_update_task aplica rampa progresiva

Usuario presiona PAUSE:
  is_paused = true
  speed_before_stop = speed_kmh
  target_speed = 0.0
  ramp_mode = PAUSE_STOP
  → Velocidad baja gradualmente a 0

Usuario presiona PLAY (tras pausa):
  is_paused = false
  is_resuming = true
  target_speed = speed_before_stop
  ramp_mode = PAUSE_RESUME
  → Velocidad sube gradualmente a velocidad anterior

Usuario presiona COOLDOWN:
  is_cooling_down = true
  target_speed = 0.0
  ramp_mode = COOLDOWN_STOP
  cooldown_climb_ramp_rate = climb_percent / 1200.0
  → Velocidad e inclinación bajan MUY lentamente (120 segundos)

4.4. SISTEMA DE AUDIO (audio.c/h)
----------------------------------

Archivo: c:\esp\Consola_Cinta\Plantilla\main\audio.c (78 líneas)
Header: c:\esp\Consola_Cinta\Plantilla\main\audio.h (9 líneas)

Propósito:
Reproducir beeps de confirmación cuando el usuario presiona botones.

Especificaciones del beep:
- Frecuencia: 1000 Hz (tono)
- Sample Rate: 44100 Hz
- Bits por muestra: 16 bits
- Canales: 1 (Mono)
- Duración: 100 ms
- Buffer: 4410 samples (44100 / 10)
- Tamaño buffer: 8820 bytes (4410 * 2)

Arquitectura:
  ESP32-P4 → I2S → ES8311 CODEC → NS4150 Amplifier → Altavoz

Configuración I2S:

i2s_chan_config_t chan_cfg = {
    .id = I2S_NUM_0,
    .role = I2S_ROLE_MASTER,
    .dma_desc_num = 4,
    .dma_frame_num = 1024,
    .auto_clear = true,
};

i2s_std_config_t std_cfg = {
    .clk_cfg = {
        .sample_rate_hz = 44100,
        .mclk_multiple = I2S_MCLK_MULTIPLE_256,
    },
    .slot_cfg = {
        .data_bit_width = I2S_DATA_BIT_WIDTH_16BIT,
        .slot_bit_width = I2S_SLOT_BIT_WIDTH_AUTO,
        .slot_mode = I2S_SLOT_MODE_MONO,
        .slot_mask = I2S_STD_SLOT_LEFT,
        .ws_width = I2S_SLOT_BIT_WIDTH_AUTO,
        .ws_pol = false,
        .bit_shift = true,
        .msb_right = false,
    },
    .gpio_cfg = {
        .mclk = GPIO_NUM_13,  // CODEC_I2S0_MCLK
        .bclk = GPIO_NUM_12,  // CODEC_I2S0_SCLK
        .ws   = GPIO_NUM_10,  // CODEC_I2S0_LRCK
        .dout = GPIO_NUM_11,  // CODEC_I2S0_DSDOUT
        .din  = GPIO_NUM_9,   // CODEC_I2S0_DSDIN
    },
};

Configuración del CODEC ES8311:

audio_codec_i2s_cfg_t i2s_cfg = {
    .rx_handle = i2s_rx_handle,
    .tx_handle = i2s_tx_handle,
};

es8311_codec_cfg_t codec_cfg = {
    .hw_gain = {
        .pa_voltage = 5.0,        // Voltaje del amplificador
        .codec_dac_voltage = 3.3, // Voltaje DAC
    },
    .codec_mode = ESP_CODEC_DEV_WORK_MODE_DAC, // Solo salida
};

Generación de beep:

void audio_init(void) {
    1. Crear canales I2S (TX y RX)
    2. Inicializar codec ES8311 via BSP
    3. Configurar volumen a 40 dB
    4. Generar tabla de onda senoidal:
       for (i = 0; i < BEEP_SAMPLE_COUNT; i++) {
           float t = (float)i / BEEP_SAMPLE_RATE;
           beep_buffer[i] = (int16_t)(sin(2.0 * M_PI * BEEP_FREQ * t) * 32767.0);
       }
}

void audio_play_beep(void) {
    size_t bytes_written;
    i2s_channel_write(i2s_tx_handle, beep_buffer,
                      BEEP_SAMPLE_COUNT * sizeof(int16_t),
                      &bytes_written, portMAX_DELAY);
}

Uso:
- Se llama desde button_handler.c cada vez que se presiona un botón
- Proporciona feedback auditivo inmediato al usuario

4.5. GESTOR DE BOTONES (button_handler.c/h)
--------------------------------------------

Archivo: c:\esp\Consola_Cinta\Plantilla\main\button_handler.c (139 líneas)
Header: c:\esp\Consola_Cinta\Plantilla\main\button_handler.h (8 líneas)

Hardware:
- Chip: MCP23017 (Expansor GPIO I2C de 16 bits)
- Dirección I2C: 0x20
- Puerto A (8 bits): Botones 1-5
- Puerto B (8 bits): Botones 6-10

Configuración I2C:

i2c_master_bus_config_t i2c_bus_cfg = {
    .i2c_port = I2C_NUM_0,
    .sda_io_num = GPIO_NUM_8,
    .scl_io_num = GPIO_NUM_7,
    .clk_source = I2C_CLK_SRC_DEFAULT,
    .glitch_ignore_cnt = 7,
    .flags.enable_internal_pullup = true,
};

i2c_device_config_t dev_cfg = {
    .dev_addr_length = I2C_ADDR_BIT_LEN_7,
    .device_address = 0x20,
    .scl_speed_hz = 100000,
};

Mapeo de botones:

Registro GPIOA (0x12):
  Bit 0: No usado
  Bit 1: SPEED_INC      → Aumentar velocidad
  Bit 2: SPEED_SET      → Ajuste manual de velocidad
  Bit 3: SPEED_DEC      → Disminuir velocidad
  Bit 4: STOP           → Parar (igual que PAUSE en este contexto)
  Bit 5: COOLDOWN       → Modo enfriamiento
  Bit 6-7: No usados

Registro GPIOB (0x13):
  Bit 0: No usado
  Bit 1: CLIMB_INC      → Aumentar inclinación
  Bit 2: CLIMB_SET      → Ajuste manual de inclinación
  Bit 3: CLIMB_DEC      → Disminuir inclinación
  Bit 4: START          → Iniciar (similar a PLAY)
  Bit 5: PAUSE_PLAY     → Pausar/Reanudar
  Bit 6-7: No usados

Configuración de MCP23017:

void button_handler_init(void) {
    1. Inicializar bus I2C
    2. Configurar MCP23017:
       - IODIR A = 0xFF (todos como entrada)
       - IODIR B = 0xFF (todos como entrada)
       - GPPU A = 0xFF (habilitar pull-ups internos)
       - GPPU B = 0xFF (habilitar pull-ups internos)
    3. Crear tarea de polling (button_handler_task)
       - Prioridad: 5
       - Stack: 2048 bytes
       - Período: 50ms (20 Hz)
}

Detección de eventos:

void button_handler_task(void *pvParameter) {
    uint8_t prev_gpio_a = 0xFF;
    uint8_t prev_gpio_b = 0xFF;

    while (1) {
        // Leer estado actual
        uint8_t gpio_a = mcp23017_read_register(0x12); // GPIOA
        uint8_t gpio_b = mcp23017_read_register(0x13); // GPIOB

        // Detectar cambios (botón presionado = bit pasa de 1 a 0)
        uint8_t changed_a = prev_gpio_a ^ gpio_a;
        uint8_t pressed_a = changed_a & ~gpio_a;

        uint8_t changed_b = prev_gpio_b ^ gpio_b;
        uint8_t pressed_b = changed_b & ~gpio_b;

        // Procesar botones presionados
        if (pressed_a & (1 << 1)) {
            audio_play_beep();
            if (pantalla_actual == MAIN) {
                ui_speed_inc();
            } else {
                ui_handle_numpad_press(6);
            }
        }
        // ... procesar resto de botones ...

        prev_gpio_a = gpio_a;
        prev_gpio_b = gpio_b;

        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

Funciones de lectura/escritura I2C:

uint8_t mcp23017_read_register(uint8_t reg)
  - Envía dirección de registro
  - Lee 1 byte
  - Retorna valor

void mcp23017_write_register(uint8_t reg, uint8_t value)
  - Escribe valor en registro específico

Comportamiento según pantalla activa:

A) PANTALLA PRINCIPAL:
  - SPEED_INC → ui_speed_inc()
  - SPEED_DEC → ui_speed_dec()
  - SPEED_SET → ui_set_speed()
  - CLIMB_INC → ui_climb_inc()
  - CLIMB_DEC → ui_climb_dec()
  - CLIMB_SET → ui_set_climb()
  - PAUSE_PLAY → ui_pause_play()
  - STOP → ui_pause_play()
  - START → ui_pause_play()
  - COOLDOWN → ui_cool_down()

B) PANTALLA DE AJUSTE (NUMPAD):
  - SPEED_INC → ui_handle_numpad_press(6)
  - SPEED_SET → ui_handle_numpad_press(7)
  - SPEED_DEC → ui_handle_numpad_press(8)
  - STOP → ui_handle_numpad_press(9)
  - COOLDOWN → ui_handle_numpad_press(0)
  - CLIMB_INC → ui_handle_numpad_press(1)
  - CLIMB_SET → ui_handle_numpad_press(2)
  - CLIMB_DEC → ui_handle_numpad_press(3)
  - START → ui_handle_numpad_press(4)
  - PAUSE_PLAY → ui_handle_numpad_press(5)

Protección contra rebotes:
- Polling a 50ms proporciona debounce natural
- Solo detecta transiciones de 1→0 (presión)
- Ignora liberaciones del botón

4.6. DRIVERS DE DISPLAY (display_driver.c/h)
---------------------------------------------

Archivo: c:\esp\Consola_Cinta\Plantilla\main\display_driver.c (121 líneas)
Header: c:\esp\Consola_Cinta\Plantilla\main\display_driver.h (19 líneas)

Propósito:
Interfaz simplificada para inicializar y controlar el display MIPI-DSI
utilizando el BSP (Board Support Package).

Hardware:
- Resolución: 800 x 1280 píxeles (10.1 pulgadas)
- Interfaz: MIPI-DSI
- Controlador: JD9365
- Orientación: Retrato, rotado 270° en software

Funciones principales:

esp_err_t display_driver_init(void)
  - Wrapper para bsp_display_start()
  - Configura buffer de LVGL
  - Inicializa controlador DSI
  - Retorna ESP_OK si exitoso

esp_err_t display_driver_backlight_on(void)
  - Activa retroiluminación al 100%
  - Utiliza GPIO47 con PWM (LEDC)

esp_err_t display_driver_backlight_off(void)
  - Desactiva retroiluminación

esp_err_t display_driver_rotate(lv_disp_rot_t rotation)
  - Permite rotar display
  - Valores: LV_DISP_ROT_NONE, 90, 180, 270
  - En este proyecto: LV_DISP_ROT_270

lv_disp_t *display_driver_get_display(void)
  - Retorna handle del display LVGL
  - Usado por ui.c para crear objetos gráficos

Configuración BSP utilizada en main.c:

bsp_display_cfg_t cfg = {
    .lvgl_port_cfg = ESP_LVGL_PORT_INIT_CONFIG(),
    .buffer_size = BSP_LCD_H_RES * BSP_LCD_V_RES,  // 800*1280
    .double_buffer = BSP_LCD_DRAW_BUFF_DOUBLE,     // Doble buffer
    .flags = {
        .buff_dma = false,         // Buffer en PSRAM, no DMA
        .buff_spiram = true,       // Buffer en SPIRAM (PSRAM)
        .sw_rotate = false,        // Sin rotación por software
    }
};

Tamaño de memoria utilizado:
- Buffer simple: 800 * 1280 * 2 bytes = 2,048,000 bytes (~2 MB)
- Doble buffer: 4,096,000 bytes (~4 MB)
- Ubicación: PSRAM externa de 32 MB

Notas:
- El BSP gestiona toda la complejidad del MIPI-DSI
- No se accede directamente a registros del JD9365
- El controlador está implementado en common_components/esp_lcd_jd9365

4.7. DRIVERS DE TOUCH (touch_driver.c/h)
-----------------------------------------

Archivo: c:\esp\Consola_Cinta\Plantilla\main\touch_driver.c (73 líneas)
Header: c:\esp\Consola_Cinta\Plantilla\main\touch_driver.h (20 líneas)

Propósito:
Interfaz para el panel táctil capacitivo GSL3680.

Hardware:
- Controlador: GSL3680
- Interfaz: I2C
- Puntos táctiles: Hasta 10 simultáneos
- Resolución: Igual al display (800x1280)

Pines:
- SCL: RTC_CLK (compartido con RTC y CODEC)
- SDA: RTC_DAT (compartido con RTC y CODEC)
- INT: GPIO46 (interrupción de toque)
- RST: GPIO45 (reset del controlador)

Funciones principales:

esp_err_t touch_driver_init(void)
  - Inicializa bus I2C
  - Configura GSL3680 vía BSP
  - Registra callback con LVGL
  - Habilita detección multitouch

void touch_driver_read_data(lv_indev_drv_t *drv, lv_indev_data_t *data)
  - Callback de LVGL para leer eventos táctiles
  - Lee coordenadas X, Y del primer punto de toque
  - Actualiza estado (presionado/liberado)
  - LVGL gestiona automáticamente gestos y objetos

Integración con LVGL:

lv_indev_drv_t indev_drv;
lv_indev_drv_init(&indev_drv);
indev_drv.type = LV_INDEV_TYPE_POINTER;
indev_drv.read_cb = touch_driver_read_data;
lv_indev_drv_register(&indev_drv);

Calibración:
- El BSP incluye tabla de calibración para GSL3680
- Mapeo directo de coordenadas táctiles a píxeles
- Sin necesidad de calibración manual

Uso:
- LVGL llama automáticamente a touch_driver_read_data() periódicamente
- Los eventos táctiles se procesan sin intervención del usuario
- Los botones virtuales en ui.c responden al toque

================================================================================
5. INTEGRACIÓN ESP32-C6 (WiFi y Bluetooth)
================================================================================

5.1. ARQUITECTURA HOST-SLAVE
-----------------------------

El sistema utiliza una arquitectura donde:
- ESP32-P4 (HOST): Gestiona la aplicación, display, audio, botones
- ESP32-C6 (SLAVE): Proporciona conectividad WiFi y Bluetooth

Comunicación:
- Protocolo: SDIO (Secure Digital Input/Output)
- Velocidad: Alta velocidad (hasta 50 MHz)
- Pines: SD2_CLK, SD2_CMD, SD2_D0-D3 (conexión interna en la placa)

5.2. COMPONENTES UTILIZADOS
----------------------------

A) espressif/esp_hosted (versión 0.*)
   - Framework principal para comunicación Host-Slave
   - Ubicación en HOST: managed_components/espressif__esp_hosted
   - Inicialización automática vía constructor C
   - API: esp_hosted_init() (llamada automáticamente)

B) espressif/esp_wifi_remote (versión 0.*)
   - Proporciona API estándar de ESP-IDF para WiFi
   - El HOST usa esp_wifi_* como si tuviera WiFi nativo
   - Transparente para la aplicación

C) Proyecto SLAVE (c:\esp\Consola_Cinta\ESP32C6_Slave)
   - Firmware independiente para ESP32-C6
   - Gestiona:
     * Controlador WiFi
     * Controlador Bluetooth HCI
     * Protocolo de comunicación con HOST
     * Transporte SDIO

5.3. CONFIGURACIÓN DEL HOST
----------------------------

Archivo: Plantilla/main/idf_component.yml

dependencies:
  lvgl/lvgl:
    version: 8.4.*
    public: true
  espressif/esp_lvgl_port: ^2.6

  # ESP32-C6 connectivity components
  espressif/esp_wifi_remote:
    version: "0.*"

  espressif/esp_hosted:
    version: "0.*"

Archivo: Plantilla/sdkconfig.defaults

# ESP32-C6 Slave Configuration for WiFi and Bluetooth
CONFIG_SLAVE_IDF_TARGET_ESP32C6=y

Importante:
- NO se requiere modificar main.c
- La inicialización es automática
- El componente esp_hosted registra un constructor C:

    __attribute__((constructor))
    void esp_hosted_host_init(void) {
        ESP_LOGI(TAG, "ESP Hosted : Host chip_ip[%d]", CONFIG_IDF_FIRMWARE_CHIP_ID);
        ESP_ERROR_CHECK(esp_hosted_init());
    }

5.4. CONFIGURACIÓN DEL SLAVE
-----------------------------

Ubicación: c:\esp\Consola_Cinta\ESP32C6_Slave

Archivo: sdkconfig.defaults

CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_160=y

# BT Configuration
CONFIG_BT_ENABLED=y
CONFIG_BT_CONTROLLER_ONLY=y
CONFIG_BT_BLUEDROID_ENABLED=
CONFIG_BT_LE_SLEEP_ENABLE=y

# SDIO transport
CONFIG_BT_LE_HCI_INTERFACE_USE_RAM=y

# Partition table
CONFIG_PARTITION_TABLE_CUSTOM=y
CONFIG_PARTITION_TABLE_CUSTOM_FILENAME="partitions.esp32c6.csv"
CONFIG_ESP_PKT_STATS=y

Archivo: partitions.esp32c6.csv

# Name, Type, SubType, Offset, Size, Flags
nvs,data,nvs,0x9000,16K,
otadata,data,ota,0xd000,8K,
phy_init,data,phy,0xf000,4K,
ota_0,app,ota_0,0x10000,1536K,
ota_1,app,ota_1,0x190000,1536K,

Total: 4MB flash (configuración OTA dual)

5.5. FIRMWARE DEL SLAVE (ESP32-C6)
-----------------------------------

Módulos principales:

A) app_main.c
   - Entry point del slave
   - Inicializa NVS, Bluetooth, WiFi
   - Configura transporte SDIO
   - Crea tareas de recepción/transmisión
   - Envía eventos de capacidades al host

B) slave_bt.c
   - Inicializa controlador Bluetooth en modo BLE
   - Configura HCI sobre VHCI (RAM)
   - Pines UART alternativos (si se usa UART):
     * TX: GPIO5
     * RX: GPIO12

C) slave_control.c
   - Implementa protocolo RPC (Remote Procedure Call)
   - Maneja comandos del host (scan WiFi, connect, etc.)
   - Envía respuestas y eventos al host

D) sdio_slave_api.c
   - Driver SDIO slave para ESP32-C6
   - Gestiona transferencias de datos con el host
   - Buffers DMA para alta velocidad

E) protocomm_pserial.c
   - Protocolo de comunicación serial
   - Encapsula mensajes RPC
   - Seguridad opcional (en este caso, deshabilitada)

Flujo de inicialización del SLAVE:

void app_main() {
    1. Inicializar NVS
    2. Inicializar Bluetooth (BLE only)
    3. Crear instancia de protocomm
    4. Agregar endpoints RPC
    5. Inicializar transporte SDIO
    6. Crear tareas recv_task y send_task
    7. Enviar evento de startup al host con capacidades:
       - WLAN over SDIO
       - BT HCI
}

5.6. USO DE WiFi DESDE EL HOST
-------------------------------

Una vez que ambos firmwares están flasheados y funcionando, el ESP32-P4
puede usar WiFi como si lo tuviera integrado:

Ejemplo:

#include "esp_wifi.h"
#include "esp_event.h"
#include "esp_netif.h"

void app_wifi_init(void) {
    // Inicializar stack TCP/IP
    ESP_ERROR_CHECK(esp_netif_init());
    ESP_ERROR_CHECK(esp_event_loop_create_default());

    // Crear interfaz WiFi Station
    esp_netif_create_default_wifi_sta();

    // Inicializar WiFi (esto internamente usa el C6)
    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_wifi_init(&cfg));

    // Configurar red
    wifi_config_t wifi_config = {
        .sta = {
            .ssid = "MI_RED",
            .password = "MI_CONTRASEÑA",
        },
    };

    ESP_ERROR_CHECK(esp_wifi_set_mode(WIFI_MODE_STA));
    ESP_ERROR_CHECK(esp_wifi_set_config(WIFI_IF_STA, &wifi_config));
    ESP_ERROR_CHECK(esp_wifi_start());
    ESP_ERROR_CHECK(esp_wifi_connect());

    ESP_LOGI(TAG, "WiFi iniciado, conectando...");
}

5.7. USO DE BLUETOOTH DESDE EL HOST
------------------------------------

El controlador Bluetooth está en el C6, pero se accede vía HCI:

#include "esp_bt.h"
#include "esp_gap_ble_api.h"

void app_bluetooth_init(void) {
    // Inicializar controlador BT (en realidad usa el C6)
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ESP_ERROR_CHECK(esp_bt_controller_init(&bt_cfg));
    ESP_ERROR_CHECK(esp_bt_controller_enable(ESP_BT_MODE_BLE));

    // Inicializar Bluedroid (stack BLE)
    ESP_ERROR_CHECK(esp_bluedroid_init());
    ESP_ERROR_CHECK(esp_bluedroid_enable());

    ESP_LOGI(TAG, "Bluetooth BLE iniciado");
}

5.8. VERIFICACIÓN DE COMUNICACIÓN P4-C6
----------------------------------------

Logs esperados del HOST (ESP32-P4):

I (xxx) host_init: ESP Hosted : Host chip_ip[18]
I (xxx) H_API: ESP-Hosted starting. Hosted_Tasks: prio:23, stack: 5120
I (xxx) transport_drv: Initializing SDIO host interface
I (xxx) sdio_drv: SDIO host initialized
I (xxx) H_API: ** add_esp_wifi_remote_channels **

Logs esperados del SLAVE (ESP32-C6):

I (xxx) fg_mcu_slave: *********************************************
I (xxx) fg_mcu_slave: ESP-Hosted-MCU Slave FW version :: 0.0.6
I (xxx) fg_mcu_slave: Transport used :: SDIO only
I (xxx) fg_mcu_slave: *********************************************
I (xxx) fg_mcu_slave: Supported features are:
I (xxx) fg_mcu_slave: - WLAN over SDIO
I (xxx) slave_bt: ESP Bluetooth MAC addr: xx:xx:xx:xx:xx:xx
I (xxx) fg_mcu_slave: Initial set up done

Si ambos logs aparecen, la comunicación SDIO está funcionando correctamente.

5.9. DOCUMENTACIÓN ADICIONAL
-----------------------------

Ver archivo completo: c:\esp\Consola_Cinta\README_ESP32C6.md

Contiene:
- Proceso de compilación detallado
- Instrucciones de flasheo paso a paso
- Ejemplos de código
- Solución de problemas
- Diagrama de arquitectura

================================================================================
6. CONFIGURACIÓN Y COMPILACIÓN
================================================================================

6.1. REQUISITOS PREVIOS
------------------------

Software necesario:
- ESP-IDF v5.4.0 o superior
- Python 3.8+
- Git
- CMake 3.5+
- Toolchain para ESP32-P4 y ESP32-C6

Verificar instalación:

    idf.py --version
    # Debe mostrar: ESP-IDF v5.4.0 o superior

6.2. COMPILACIÓN DEL HOST (ESP32-P4)
-------------------------------------

1. Navegar al proyecto:
   cd c:\esp\Consola_Cinta\Plantilla

2. Configurar target (si es la primera vez):
   idf.py set-target esp32p4

3. Descargar componentes gestionados:
   idf.py reconfigure

   Esto descargará:
   - espressif__esp_wifi_remote
   - espressif__esp_hosted
   - lvgl__lvgl
   - Y todas las dependencias

4. Configurar opciones (opcional):
   idf.py menuconfig

   Configuraciones importantes:
   - Component config → LVGL configuration
   - Component config → ESP32P4-Specific
   - Board Support Package

5. Compilar:
   idf.py build

   Duración aproximada: 5-10 minutos (primera vez)

6. Flashear:
   idf.py -p COM_P4 flash

   Donde COM_P4 es el puerto del ESP32-P4 (ej: COM3, COM4)

7. Monitor serial:
   idf.py -p COM_P4 monitor

   Para salir: Ctrl+]

Resultado esperado:
- Archivos binarios en: build/
- Firmware principal: build/lvgl_demo_v8.bin
- Bootloader: build/bootloader/bootloader.bin
- Partition table: build/partition_table/partition-table.bin

6.3. COMPILACIÓN DEL SLAVE (ESP32-C6)
--------------------------------------

1. Navegar al proyecto:
   cd c:\esp\Consola_Cinta\ESP32C6_Slave

2. Configurar target:
   idf.py set-target esp32c6

3. Compilar:
   idf.py build

   Duración aproximada: 3-5 minutos

4. Flashear:
   idf.py -p COM_C6 flash

   Donde COM_C6 es el puerto del ESP32-C6

   NOTA: El ESP32-C6 puede no tener puerto USB directo.
   Consulta el manual de tu placa para determinar cómo flashear el C6.
   Posibles métodos:
   - Puerto USB dedicado
   - A través del P4 en modo passthrough
   - Pines UART externos

5. Monitor serial (si es posible):
   idf.py -p COM_C6 monitor

Resultado esperado:
- Archivos binarios en: build/
- Firmware slave: build/esp32c6_slave.bin
- Particiones OTA configuradas

6.4. SCRIPT DE COMPILACIÓN AUTOMÁTICA
--------------------------------------

Puedes crear un archivo batch para automatizar:

Archivo: build_all.bat

@echo off
echo ================================================
echo Compilando Proyecto Consola_Cinta
echo ================================================

echo.
echo [1/2] Compilando HOST (ESP32-P4)...
cd c:\esp\Consola_Cinta\Plantilla
call idf.py build
if %ERRORLEVEL% NEQ 0 (
    echo ERROR: Falló compilación del HOST
    pause
    exit /b 1
)

echo.
echo [2/2] Compilando SLAVE (ESP32-C6)...
cd c:\esp\Consola_Cinta\ESP32C6_Slave
call idf.py build
if %ERRORLEVEL% NEQ 0 (
    echo ERROR: Falló compilación del SLAVE
    pause
    exit /b 1
)

echo.
echo ================================================
echo Compilación exitosa!
echo ================================================
echo.
echo Binarios HOST: c:\esp\Consola_Cinta\Plantilla\build\
echo Binarios SLAVE: c:\esp\Consola_Cinta\ESP32C6_Slave\build\
echo.
pause

6.5. CONFIGURACIONES IMPORTANTES DEL SDK
-----------------------------------------

Archivo: Plantilla/sdkconfig.defaults

# Target
CONFIG_IDF_TARGET="esp32p4"

# Flash
CONFIG_ESPTOOLPY_FLASHMODE_QIO=y
CONFIG_ESPTOOLPY_FLASHSIZE_16MB=y
CONFIG_PARTITION_TABLE_CUSTOM=y

# Optimización
CONFIG_COMPILER_OPTIMIZATION_PERF=y

# PSRAM
CONFIG_SPIRAM=y
CONFIG_SPIRAM_SPEED_200M=y
CONFIG_SPIRAM_XIP_FROM_PSRAM=y
CONFIG_CACHE_L2_CACHE_256KB=y
CONFIG_CACHE_L2_CACHE_LINE_128B=y

# FreeRTOS
CONFIG_ESP_MAIN_TASK_STACK_SIZE=10240
CONFIG_FREERTOS_HZ=1000
CONFIG_FREERTOS_VTASKLIST_INCLUDE_COREID=y
CONFIG_FREERTOS_GENERATE_RUN_TIME_STATS=y

# LVGL
CONFIG_LV_COLOR_SCREEN_TRANSP=y
CONFIG_LV_MEM_CUSTOM=y
CONFIG_LV_MEMCPY_MEMSET_STD=y
CONFIG_LV_DISP_DEF_REFR_PERIOD=15
CONFIG_LV_CIRCLE_CACHE_SIZE=10
CONFIG_LV_LAYER_SIMPLE_BUF_SIZE=102400
CONFIG_LV_IMG_CACHE_DEF_SIZE=5
CONFIG_LV_GRAD_CACHE_DEF_SIZE=10240
CONFIG_LV_USE_PERF_MONITOR=y
CONFIG_LV_ATTRIBUTE_FAST_MEM_USE_IRAM=y

# Fuentes LVGL (Montserrat 8-44 pt)
CONFIG_LV_FONT_MONTSERRAT_8=y
CONFIG_LV_FONT_MONTSERRAT_10=y
CONFIG_LV_FONT_MONTSERRAT_12=y
# ... (todas hasta 44)

# LVGL Demos
CONFIG_LV_USE_DEMO_WIDGETS=y
CONFIG_LV_USE_DEMO_BENCHMARK=y
CONFIG_LV_USE_DEMO_STRESS=y
CONFIG_LV_USE_DEMO_MUSIC=y
CONFIG_LV_DEMO_MUSIC_AUTO_PLAY=y

# Experimental features
CONFIG_IDF_EXPERIMENTAL_FEATURES=y

# Audio codec compatibility
CONFIG_CODEC_I2C_BACKWARD_COMPATIBLE=n

# ESP32-C6 Slave
CONFIG_SLAVE_IDF_TARGET_ESP32C6=y

6.6. LIMPIEZA Y RECONSTRUCCIÓN
-------------------------------

Si encuentras problemas, limpia y recompila:

# HOST
cd c:\esp\Consola_Cinta\Plantilla
idf.py fullclean
rm -rf build/ managed_components/ sdkconfig
idf.py set-target esp32p4
idf.py reconfigure
idf.py build

# SLAVE
cd c:\esp\Consola_Cinta\ESP32C6_Slave
idf.py fullclean
rm -rf build/ sdkconfig
idf.py set-target esp32c6
idf.py build

================================================================================
7. PARTICIONES DE MEMORIA
================================================================================

7.1. PARTICIONES DEL HOST (ESP32-P4)
-------------------------------------

Archivo: Plantilla/partitions.csv

# Name,   Type, SubType, Offset,  Size, Flags
nvs,      data, nvs,     0x9000,  0x6000,
phy_init, data, phy,     0xf000,  0x1000,
factory,  app,  factory, ,        8M,
storage,  data, spiffs,  ,        7M,

Desglose:

Partición       Tipo      SubTipo   Offset     Tamaño    Descripción
----------------------------------------------------------------------------
nvs             data      nvs       0x9000     24 KB     Non-Volatile Storage
                                                          (configuración WiFi,
                                                          datos persistentes)

phy_init        data      phy       0xf000     4 KB      Calibración RF
                                                          (no usado en P4)

factory         app       factory   0x10000    8 MB      Aplicación principal
                                                          (firmware)

storage         data      spiffs    auto       7 MB      Sistema de archivos
                                                          SPIFFS (assets, logs)

Total usado: ~15 MB de los 16 MB disponibles

Uso de memoria flash:
- Firmware compilado: ~2-3 MB
- Espacio libre en factory: ~5-6 MB (para futuro crecimiento)
- SPIFFS: 7 MB para archivos (fuentes, imágenes, audio)

7.2. PARTICIONES DEL SLAVE (ESP32-C6)
--------------------------------------

Archivo: ESP32C6_Slave/partitions.esp32c6.csv

# Name, Type, SubType, Offset, Size, Flags
nvs,data,nvs,0x9000,16K,
otadata,data,ota,0xd000,8K,
phy_init,data,phy,0xf000,4K,
ota_0,app,ota_0,0x10000,1536K,
ota_1,app,ota_1,0x190000,1536K,

Desglose:

Partición       Tipo      SubTipo   Offset      Tamaño    Descripción
-----------------------------------------------------------------------------
nvs             data      nvs       0x9000      16 KB     Non-Volatile Storage

otadata         data      ota       0xd000      8 KB      Datos de OTA
                                                           (indica partición activa)

phy_init        data      phy       0xf000      4 KB      Calibración WiFi/BT

ota_0           app       ota_0     0x10000     1536 KB   Firmware slot 0
                                                           (app principal)

ota_1           app       ota_1     0x190000    1536 KB   Firmware slot 1
                                                           (para actualizaciones OTA)

Total usado: ~3 MB de los 4 MB disponibles

Esquema OTA:
- Permite actualizaciones over-the-air del firmware del C6
- Dos slots alternos (ota_0 y ota_1)
- El bootloader selecciona cuál slot arrancar según otadata

7.3. DISTRIBUCIÓN DE MEMORIA RAM (ESP32-P4)
--------------------------------------------

Tipo           Tamaño        Uso Principal
------------------------------------------------------------------
HP L2MEM       768 KB        Código y datos en ejecución
LP SRAM        32 KB         Low-power tasks (RTC)
PSRAM          32 MB         Buffers de display, LVGL, heap dinámico
ROM            128 KB        Bootloader y funciones del sistema

Uso típico en tiempo de ejecución:

Memoria interna (768 KB):
- Stack de tareas: ~50 KB
- Heap interno: ~400 KB
- Variables globales: ~20 KB
- Código en cache: ~200 KB
- Resto: disponible

PSRAM (32 MB):
- Buffers de display (double buffer): ~4 MB
- LVGL objetos y cache: ~2 MB
- Audio buffers: ~100 KB
- Heap de aplicación: ~25 MB disponible

Configuración de heap:

I (xxx) heap_init: Initializing. RAM available for dynamic allocation:
I (xxx) heap_init: At 4FF23590 len 00017A30 (94 KiB): RAM
I (xxx) heap_init: At 4FF3AFC0 len 00004BF0 (18 KiB): RAM
I (xxx) heap_init: At 4FF40000 len 00040000 (256 KiB): RAM
I (xxx) heap_init: At 50108098 len 00007F68 (31 KiB): RTCRAM
I (xxx) heap_init: At 30100068 len 00001F98 (7 KiB): TCM
I (xxx) esp_psram: Adding pool of 22272K of PSRAM memory to heap allocator

Total RAM interna disponible: ~400 KB
Total PSRAM disponible: ~22 MB (el resto usado por buffers de display)

7.4. DISTRIBUCIÓN DE MEMORIA RAM (ESP32-C6)
--------------------------------------------

Tipo           Tamaño        Uso Principal
------------------------------------------------------------------
SRAM           320 KB        Código, datos, heap
ROM            128 KB        Bootloader y funciones del sistema

Uso típico:
- Stack de tareas: ~30 KB
- Heap dinámico: ~200 KB
- Controlador WiFi: ~50 KB
- Controlador BT: ~30 KB
- Buffers SDIO: ~10 KB

El C6 no tiene PSRAM, por lo que todo debe caber en los 320 KB de SRAM.

================================================================================
8. DEPENDENCIAS Y COMPONENTES
================================================================================

8.1. COMPONENTES GESTIONADOS (MANAGED_COMPONENTS)
--------------------------------------------------

Estos componentes se descargan automáticamente desde el IDF Component Registry
cuando ejecutas `idf.py reconfigure`.

A) LVGL y Gráficos
-------------------

lvgl/lvgl (v8.4.*)
  - Biblioteca gráfica principal
  - Widgets, estilos, eventos
  - Motor de renderizado
  - URL: https://github.com/lvgl/lvgl

espressif/esp_lvgl_port (^2.6)
  - Puerto de LVGL para ESP32
  - Integración con FreeRTOS
  - Gestión de memoria y DMA
  - URL: https://components.espressif.com/components/espressif/esp_lvgl_port

B) Display y Touch
-------------------

espressif/esp_lcd_touch
  - Framework para paneles táctiles
  - Soporte para múltiples controladores
  - Calibración y gestos

espressif/esp_lcd_touch_gt911
  - Driver específico para GT911 (no usado en este proyecto)

espressif/esp_lcd_ek79007
  - Driver para LCD EK79007 (alternativo)

espressif/esp_lcd_ili9881c
  - Driver para LCD ILI9881C (alternativo)

C) Audio
---------

espressif/esp_codec_dev
  - Framework de codec de audio
  - Soporte para ES8311, ES8388, etc.
  - Gestión de I2S

chmorgan/esp-audio-player
  - Reproductor de audio
  - Soporta MP3, WAV

chmorgan/esp-libhelix-mp3
  - Decodificador MP3 Helix
  - Optimizado para ESP32

chmorgan/esp-file-iterator
  - Utilidad para iterar archivos
  - Usado por el reproductor de audio

D) ESP32-C6 Connectivity
--------------------------

espressif/esp_wifi_remote (0.*)
  - API de WiFi remoto
  - Transparente para la aplicación
  - Comunicación con slave

espressif/esp_hosted (0.*)
  - Framework Host-Slave
  - Transporte SDIO/SPI/UART
  - Protocolo RPC

espressif/eppp_link
  - Protocolo PPP para datos
  - Usado por esp_wifi_remote

espressif/esp_serial_slave_link
  - Protocolo de comunicación serial
  - Encapsulación de paquetes

espressif/wifi_remote_over_eppp
  - WiFi sobre PPP
  - Integración completa

E) Utilidades
--------------

espressif/cmake_utilities
  - Utilidades de CMake
  - Scripts de construcción
  - Generación de binarios

8.2. COMPONENTES LOCALES (COMPONENTS/)
---------------------------------------

espressif__esp_lvgl_port (copia local)
  - Versión personalizada del puerto LVGL
  - Modificaciones específicas del proyecto

8.3. COMPONENTES COMUNES (COMMON_COMPONENTS/)
----------------------------------------------

Estos componentes son compartidos entre proyectos y están en el nivel superior.

esp32_p4_function_ev_board/
  - BSP (Board Support Package) principal
  - Inicialización de hardware
  - API de alto nivel para display, touch, audio
  - Archivo principal: bsp/esp-bsp.h

bsp_extra/
  - Extensiones del BSP
  - Funciones adicionales para codec de audio
  - Configuración personalizada
  - Archivo: bsp_board_extra.h

esp_lcd_touch_gsl3680/
  - Driver para panel táctil GSL3680
  - Usado en este proyecto
  - Soporte para multitouch

esp_lcd_jd9365/
  - Driver para LCD JD9365 (10.1")
  - Controlador principal de display
  - Implementa comandos MIPI-DSI

espressif__esp_lcd_jd9165/
  - Driver alternativo para JD9165
  - No usado, pero disponible

8.4. ÁRBOL DE DEPENDENCIAS
---------------------------

Plantilla (main.c)
  ├── esp-bsp (BSP)
  │   ├── display.h
  │   │   └── esp_lcd_jd9365 (driver LCD)
  │   ├── touch.h
  │   │   └── esp_lcd_touch_gsl3680 (driver touch)
  │   └── esp-bsp.h
  │
  ├── bsp_board_extra (audio)
  │   └── esp_codec_dev
  │       └── ES8311 (codec)
  │
  ├── lvgl (UI)
  │   └── esp_lvgl_port
  │       └── FreeRTOS integration
  │
  ├── esp_wifi_remote (WiFi)
  │   ├── esp_hosted
  │   │   └── SDIO transport
  │   └── eppp_link
  │       └── wifi_remote_over_eppp
  │
  └── FreeRTOS
      ├── tasks
      ├── queues
      └── semaphores

8.5. VERSIONES DE SOFTWARE
---------------------------

Framework:
- ESP-IDF: v5.4.0
- CMake: 3.5+
- Python: 3.8+

Componentes principales:
- LVGL: 8.4.* (última estable de la serie 8)
- esp_lvgl_port: ^2.6
- esp_wifi_remote: 0.* (última)
- esp_hosted: 0.* (última)

Toolchain:
- GCC para RISC-V: 13.2.0 (ESP32-P4, ESP32-C6)
- Newlib: 4.3.0
- esptool: 4.7+

================================================================================
9. TAREAS Y SINCRONIZACIÓN
================================================================================

9.1. TAREAS DE FREERTOS
------------------------

El sistema utiliza 4 tareas principales:

A) TAREA PRINCIPAL (Main Task)
-------------------------------
Nombre: main_task (implícita)
Prioridad: 1
Stack: 10240 bytes (configurado)
Función: app_main()

Responsabilidades:
- Inicialización de hardware
- Creación de mutex y otras tareas
- Termina después de la inicialización

B) TAREA DE ACTUALIZACIÓN DE UI
--------------------------------
Nombre: ui_update_task
Prioridad: 5
Stack: 4096 bytes
Período: 100 ms (10 Hz)
Función: ui_update_task()

Responsabilidades:
- Aplicar rampas de velocidad e inclinación
- Calcular tiempo, distancia, pulso, calorías
- Actualizar labels de LVGL
- Sincronización con g_state_mutex

Pseudocódigo:

void ui_update_task(void *pvParameter) {
    while (1) {
        xSemaphoreTake(g_state_mutex, portMAX_DELAY);

        // Aplicar rampa de velocidad
        if (g_treadmill_state.speed_kmh < g_treadmill_state.target_speed) {
            g_treadmill_state.speed_kmh += ramp_rate * 0.1;
        } else if (g_treadmill_state.speed_kmh > g_treadmill_state.target_speed) {
            g_treadmill_state.speed_kmh -= ramp_rate * 0.1;
        }

        // Calcular distancia
        if (!g_treadmill_state.is_paused) {
            g_treadmill_state.total_distance_km +=
                (g_treadmill_state.speed_kmh / 3600.0) * 0.1;
            g_treadmill_state.elapsed_seconds++;
        }

        // Simular pulso
        g_treadmill_state.sim_pulse = 80 +
            (int)(g_treadmill_state.speed_kmh * 6.0);

        xSemaphoreGive(g_state_mutex);

        // Actualizar UI (LVGL es thread-safe internamente)
        lv_label_set_text(lv_label_speed, buffer_speed);
        lv_label_set_text(lv_label_time, buffer_time);
        // ...

        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

C) TAREA DE GESTIÓN DE BOTONES
-------------------------------
Nombre: button_handler_task
Prioridad: 5
Stack: 2048 bytes
Período: 50 ms (20 Hz)
Función: button_handler_task()

Responsabilidades:
- Leer estado de MCP23017 vía I2C
- Detectar cambios en botones (presiones)
- Llamar a funciones de UI correspondientes
- Reproducir beep de confirmación

Pseudocódigo:

void button_handler_task(void *pvParameter) {
    uint8_t prev_gpio_a = 0xFF;
    uint8_t prev_gpio_b = 0xFF;

    while (1) {
        // Leer estado actual
        uint8_t gpio_a = mcp23017_read_register(MCP23017_GPIOA);
        uint8_t gpio_b = mcp23017_read_register(MCP23017_GPIOB);

        // Detectar cambios (presión = transición 1→0)
        uint8_t pressed_a = (prev_gpio_a ^ gpio_a) & ~gpio_a;
        uint8_t pressed_b = (prev_gpio_b ^ gpio_b) & ~gpio_b;

        // Procesar botones
        if (pressed_a & (1 << 1)) {  // SPEED_INC
            audio_play_beep();
            if (current_screen == MAIN) {
                ui_speed_inc();
            } else {
                ui_handle_numpad_press(6);
            }
        }
        // ... resto de botones ...

        prev_gpio_a = gpio_a;
        prev_gpio_b = gpio_b;

        vTaskDelay(pdMS_TO_TICKS(50));
    }
}

D) TAREA DE LVGL
-----------------
Nombre: lv_timer_task (interna de LVGL)
Prioridad: Configurada por BSP (típicamente 4)
Stack: Configurado por BSP
Período: Variable (según eventos)
Función: Renderizado y eventos

Responsabilidades:
- Renderizar gráficos en el buffer
- Procesar eventos táctiles
- Gestionar animaciones
- Actualizar objetos LVGL

Esta tarea es creada automáticamente por el BSP al llamar a bsp_display_start().

9.2. SINCRONIZACIÓN Y COMUNICACIÓN
-----------------------------------

A) MUTEX
---------

g_state_mutex (SemaphoreHandle_t)
  - Tipo: Mutex binario
  - Propósito: Proteger acceso a g_treadmill_state
  - Usado por:
    * ui_update_task (lectura/escritura)
    * button_handler_task (escritura indirecta via funciones UI)
    * Funciones ui_* (escritura)

Patrón de uso:

void ui_speed_inc(void) {
    xSemaphoreTake(g_state_mutex, portMAX_DELAY);

    if (g_treadmill_state.speed_kmh < 19.5) {
        g_treadmill_state.target_speed = g_treadmill_state.speed_kmh + 0.1;
        g_treadmill_state.ramp_mode = RAMP_MODE_NORMAL;
    }

    xSemaphoreGive(g_state_mutex);
}

B) TIMERS
----------

lv_timer_t *blink_timer
  - Tipo: Timer de LVGL (no FreeRTOS)
  - Período: 500 ms
  - Propósito: Parpadeo del cursor en pantalla de ajuste
  - Callback: cursor_blink_callback()

void cursor_blink_callback(lv_timer_t *timer) {
    g_treadmill_state.blink_state = !g_treadmill_state.blink_state;

    if (g_treadmill_state.blink_state) {
        // Mostrar cursor
        lv_label_set_text(lv_label_numpad_value, "12.5_");
    } else {
        // Ocultar cursor
        lv_label_set_text(lv_label_numpad_value, "12.5 ");
    }
}

C) COLAS (NO USADAS)
---------------------

El proyecto actual NO utiliza colas FreeRTOS. Toda la comunicación se realiza
mediante variables globales protegidas por mutex.

Si en el futuro se añadiera conectividad WiFi/BT, podrían usarse colas para:
- Enviar comandos desde UI a módulo de red
- Recibir eventos de red (conexión, desconexión, datos)

D) EVENTOS DE LVGL
-------------------

LVGL tiene su propio sistema de eventos para objetos gráficos:

// Botón de velocidad +
lv_obj_add_event_cb(lv_btn_speed_inc, speed_inc_event_handler,
                    LV_EVENT_CLICKED, NULL);

void speed_inc_event_handler(lv_event_t *e) {
    audio_play_beep();
    ui_speed_inc();
}

Eventos comunes:
- LV_EVENT_CLICKED: Objeto fue tocado/clickeado
- LV_EVENT_PRESSED: Objeto está siendo presionado
- LV_EVENT_RELEASED: Objeto fue liberado
- LV_EVENT_VALUE_CHANGED: Valor cambió (sliders, switches)

9.3. GESTIÓN DE MEMORIA
------------------------

A) HEAP INTERNO (RAM)
----------------------

Usado para:
- Estructuras pequeñas
- Buffers temporales
- Stacks de tareas

Asignación:

void *ptr = malloc(size);          // Heap por defecto
void *ptr = heap_caps_malloc(size, MALLOC_CAP_INTERNAL); // Forzar interno

B) HEAP EXTERNO (PSRAM)
------------------------

Usado para:
- Buffers grandes (display, audio)
- Objetos LVGL
- Datos dinámicos de la aplicación

Asignación:

void *ptr = heap_caps_malloc(size, MALLOC_CAP_SPIRAM); // PSRAM

LVGL automáticamente usa PSRAM gracias a esta configuración:

#define LV_MEM_CUSTOM 1
#define LV_MEM_CUSTOM_ALLOC(size)   heap_caps_malloc(size, MALLOC_CAP_SPIRAM)
#define LV_MEM_CUSTOM_FREE(ptr)     heap_caps_free(ptr)

C) ANÁLISIS DE MEMORIA EN TIEMPO DE EJECUCIÓN
-----------------------------------------------

Para debuggear uso de memoria:

esp_err_t heap_caps_get_info(heap_caps_t caps, multi_heap_info_t *info);

Ejemplo:

void print_heap_stats(void) {
    multi_heap_info_t internal_info;
    heap_caps_get_info(&internal_info, MALLOC_CAP_INTERNAL);

    ESP_LOGI(TAG, "Heap interno:");
    ESP_LOGI(TAG, "  Total: %u bytes", internal_info.total_allocated_bytes);
    ESP_LOGI(TAG, "  Libre: %u bytes", internal_info.total_free_bytes);
    ESP_LOGI(TAG, "  Usado: %u bytes", internal_info.total_allocated_bytes);

    multi_heap_info_t psram_info;
    heap_caps_get_info(&psram_info, MALLOC_CAP_SPIRAM);

    ESP_LOGI(TAG, "PSRAM:");
    ESP_LOGI(TAG, "  Total: %u bytes", psram_info.total_allocated_bytes);
    ESP_LOGI(TAG, "  Libre: %u bytes", psram_info.total_free_bytes);
    ESP_LOGI(TAG, "  Usado: %u bytes", psram_info.total_allocated_bytes);
}

================================================================================
10. FLUJO DE EJECUCIÓN
================================================================================

10.1. ARRANQUE DEL SISTEMA
---------------------------

1. BOOTLOADER (ROM)
   - Reset del chip
   - Inicialización de reloj y memoria
   - Carga del bootloader de segundo nivel

2. BOOTLOADER (SEGUNDO NIVEL)
   - Lee partition table
   - Verifica integridad de firmware
   - Carga aplicación desde partition "factory"
   - Salta a punto de entrada (app_main)

3. INICIALIZACIÓN DE ESP-IDF
   - Configuración de memoria (heap, cache)
   - Inicialización de FreeRTOS
   - Creación de tarea principal
   - Llamada a app_main()

4. APLICACIÓN (app_main)
   ┌────────────────────────────────────────┐
   │ void app_main(void)                    │
   ├────────────────────────────────────────┤
   │ 1. Crear mutex (g_state_mutex)         │
   │ 2. Inicializar display                 │
   │    - bsp_display_start()               │
   │    - bsp_display_backlight_on()        │
   │    - bsp_display_rotate(270°)          │
   │ 3. Inicializar UI                      │
   │    - ui_init()                         │
   │ 4. Inicializar audio                   │
   │    - audio_init()                      │
   │ 5. Inicializar botones                 │
   │    - button_handler_init()             │
   │ 6. Crear tarea de actualización UI     │
   │    - xTaskCreate(ui_update_task)       │
   │ 7. Retornar (tarea main termina)       │
   └────────────────────────────────────────┘

5. INICIALIZACIÓN AUTOMÁTICA (ESP_HOSTED)
   - Constructor C ejecutado antes de main()
   - esp_hosted_init() inicializa comunicación con C6
   - Se ejecuta en segundo plano

6. LOOP PRINCIPAL (TAREAS)
   - Sistema entra en scheduler de FreeRTOS
   - Tareas se ejecutan según prioridad y tiempo
   - Loop infinito hasta apagado

10.2. SECUENCIA DE INICIALIZACIÓN DETALLADA
--------------------------------------------

TIEMPO   ACCIÓN                                   RESPONSABLE
----------------------------------------------------------------------
T+0ms    Reset del sistema                        Hardware
T+10ms   Bootloader ROM ejecutándose              ROM
T+50ms   Bootloader secundario cargado            Flash
T+100ms  Aplicación cargada en RAM                Bootloader
T+150ms  FreeRTOS iniciado                        ESP-IDF
T+200ms  app_main() ejecutándose                  Aplicación

T+210ms  Mutex creado                             app_main
T+220ms  Display inicializando...                 BSP
T+800ms  Display listo (MIPI-DSI configurado)     BSP
T+850ms  Backlight encendido                      BSP
T+900ms  UI inicializada (LVGL)                   ui_init
T+1100ms Audio inicializado (I2S + ES8311)        audio_init
T+1200ms Botones inicializados (MCP23017)         button_handler_init
T+1250ms Tarea UI creada                          app_main
T+1300ms Sistema operativo y listo                -

T+1350ms Primer frame renderizado                 LVGL
T+1400ms Primera lectura de botones               button_handler_task
T+1500ms Primera actualización de UI              ui_update_task

TOTAL: ~1.5 segundos desde reset hasta sistema completamente operativo

10.3. CICLO DE VIDA DE UNA INTERACCIÓN DE USUARIO
--------------------------------------------------

Ejemplo: Usuario presiona botón SPEED +

1. DETECCIÓN (t=0ms)
   - GPIO del MCP23017 cambia de HIGH a LOW
   - button_handler_task está en sleep

2. POLLING (t=0-50ms)
   - Tarea despierta en su ciclo de 50ms
   - Lee registros I2C del MCP23017
   - Detecta cambio: (prev_gpio ^ curr_gpio) & ~curr_gpio

3. PROCESAMIENTO (t=50ms)
   - Identifica botón presionado: SPEED_INC (GPIO A, bit 1)
   - Reproduce beep: audio_play_beep()
     * Envía buffer de 4410 samples via I2S
     * Duración del beep: 100ms
   - Llama a ui_speed_inc()

4. MODIFICACIÓN DE ESTADO (t=51ms)
   - ui_speed_inc() toma mutex
   - Incrementa target_speed en 0.1 km/h
   - Establece ramp_mode = RAMP_MODE_NORMAL
   - Libera mutex

5. APLICACIÓN DE RAMPA (t=100ms, 200ms, 300ms...)
   - ui_update_task despierta cada 100ms
   - Compara speed_kmh con target_speed
   - Aplica incremento: speed_kmh += 0.5 * 0.1 (5 km/h/s)
   - Continúa hasta alcanzar target_speed

6. ACTUALIZACIÓN VISUAL (t=100ms, 200ms, 300ms...)
   - ui_update_task actualiza labels
   - lv_label_set_text(lv_label_speed, "5.2 km/h")
   - LVGL marca objeto como "dirty"

7. RENDERIZADO (t=115ms, 215ms, 315ms...)
   - Tarea de LVGL detecta objetos dirty
   - Redibuja área afectada en buffer
   - Envía buffer a display via MIPI-DSI
   - Usuario ve velocidad aumentar suavemente

TOTAL: Desde presión de botón hasta velocidad final:
- Beep inmediato: ~50ms
- Incremento visible: ~100ms
- Rampa completa (ej: 0→10 km/h): ~2 segundos

10.4. DIAGRAMA DE ESTADOS DE LA TROTADORA
------------------------------------------

                    ┌─────────────┐
                    │   INICIAL   │
                    │ speed = 0.0 │
                    │ paused = no │
                    └──────┬──────┘
                           │
                    SPEED + presionado
                           │
                           ▼
                    ┌─────────────┐
                    │   RUNNING   │◄────┐
                    │ speed > 0.0 │     │
                    │ paused = no │     │
                    └──┬────────┬─┘     │
                       │        │       │
         PAUSE         │        │       │ PLAY
         presionado    │        │       │ presionado
                       │        │       │
                       ▼        │       │
                ┌──────────┐   │    ┌──────────┐
                │  PAUSED  │   │    │ RESUMING │
                │ speed=0.0│   │    │rampa sube│
                │pause=yes │   │    └────┬─────┘
                └────┬─────┘   │         │
                     │         │         │
                     └─────────┴─────────┘
                           │
                           │ COOLDOWN
                           │ presionado
                           ▼
                    ┌─────────────┐
                    │  COOLDOWN   │
                    │ rampa lenta │
                    │ 120 segundos│
                    └──────┬──────┘
                           │
                    speed alcanza 0
                           │
                           ▼
                    ┌─────────────┐
                    │  TERMINADO  │
                    │ speed = 0.0 │
                    │ climb = 0.0 │
                    └─────────────┘

10.5. DIAGRAMA DE SECUENCIA: AJUSTE MANUAL DE VELOCIDAD
--------------------------------------------------------

Usuario           Botón Handler      UI (Main Screen)    UI (Numpad Screen)    State
  │                    │                    │                     │              │
  │  Presiona SET      │                    │                     │              │
  ├────────────────────►                    │                     │              │
  │                    │  audio_beep()      │                     │              │
  │                    ├────────────────────►                     │              │
  │                    │  ui_set_speed()    │                     │              │
  │                    ├─────────────────────────────────────────►│              │
  │                    │                    │  lv_scr_load(numpad)│              │
  │                    │                    │                     ├─────────────►│
  │                    │                    │                     │ set_mode=    │
  │                    │                    │                     │   SPEED      │
  │                    │                    │                     │ buffer=""    │
  │                    │                    │                     │ index=0      │
  │                    │                    │                     │◄─────────────┤
  │  Presiona "1"      │                    │                     │              │
  ├────────────────────►                    │                     │              │
  │                    │  ui_handle_numpad_press(1)               │              │
  │                    ├──────────────────────────────────────────►              │
  │                    │                    │                     ├─────────────►│
  │                    │                    │                     │ buffer[0]='1'│
  │                    │                    │                     │ index=1      │
  │                    │                    │                     │ display "1_" │
  │                    │                    │                     │◄─────────────┤
  │  Presiona "9"      │                    │                     │              │
  ├────────────────────►                    │                     │              │
  │                    │  ui_handle_numpad_press(9)               │              │
  │                    ├──────────────────────────────────────────►              │
  │                    │                    │                     ├─────────────►│
  │                    │                    │                     │ buffer[1]='9'│
  │                    │                    │                     │ index=2      │
  │                    │                    │                     │ display "1.9_│
  │                    │                    │                     │◄─────────────┤
  │  Presiona "5"      │                    │                     │              │
  ├────────────────────►                    │                     │              │
  │                    │  ui_handle_numpad_press(5)               │              │
  │                    ├──────────────────────────────────────────►              │
  │                    │                    │                     ├─────────────►│
  │                    │                    │                     │ buffer[2]='5'│
  │                    │                    │                     │ index=3      │
  │                    │                    │                     │ COMPLETO!    │
  │                    │                    │  ui_confirm_set_value()            │
  │                    │                    │◄─────────────────────              │
  │                    │                    │                     │              │
  │                    │                    ├────────────────────────────────────►
  │                    │                    │                     │ Parse "195"  │
  │                    │                    │                     │ = 19.5 km/h  │
  │                    │                    │                     │ Validar OK   │
  │                    │                    │                     │ target=19.5  │
  │                    │                    │                     │ ramp=NORMAL  │
  │                    │                    │  lv_scr_load(main)  │◄─────────────┤
  │                    │                    │◄─────────────────────              │
  │                    │                    │                     │              │
  │  Ve pantalla       │                    │                     │              │
  │  principal         │                    │                     │              │
  │  Velocidad         │                    │                     │              │
  │  subiendo          │                    │                     │              │
  │◄───────────────────────────────────────┘                     │              │

Duración total: ~5 segundos (3 segundos ingresando dígitos + 2 segundos de rampa)

================================================================================
11. NOTAS DE DESARROLLO
================================================================================

11.1. CONVENCIONES DE CÓDIGO
-----------------------------

A) NOMENCLATURA
----------------

Variables globales:    g_nombre_variable
  Ejemplo: g_treadmill_state, g_state_mutex

Funciones públicas:    modulo_accion()
  Ejemplo: ui_speed_inc(), audio_play_beep()

Funciones privadas:    _accion() o accion_impl()
  Ejemplo: _render_main_screen()

Constantes:            NOMBRE_EN_MAYUSCULAS
  Ejemplo: MAX_SPEED_KMH, BEEP_SAMPLE_RATE

Tipos:                 NombreType_t o nombre_t
  Ejemplo: TreadmillState, ramp_mode_t

B) FORMATO
-----------

- Indentación: 4 espacios (NO tabs)
- Llaves: Estilo K&R
  void funcion() {
      if (condicion) {
          codigo;
      }
  }

- Líneas: Máximo 100 caracteres (flexible)
- Comentarios: // para línea, /* */ para bloque

C) COMENTARIOS
---------------

Funciones públicas:

/**
 * @brief Descripción breve
 *
 * Descripción detallada si es necesario
 *
 * @param param1 Descripción del parámetro
 * @return Descripción del retorno
 */
void funcion(int param1);

Código:

// Comentario explicativo de una línea
codigo;

/* Comentario de bloque
   para explicaciones más largas */

11.2. PATRONES DE DISEÑO UTILIZADOS
------------------------------------

A) SINGLETON
-------------

Estado global único:
TreadmillState g_treadmill_state;

Solo existe una instancia del estado de la trotadora.

B) FACADE
----------

Los drivers (display_driver, touch_driver, audio) actúan como facades:
- Ocultan complejidad del BSP
- Proporcionan API simplificada
- Ejemplo:
  void display_driver_backlight_on(void) {
      bsp_display_backlight_on();  // Oculta detalles de LEDC/PWM
  }

C) OBSERVER (LVGL Events)
--------------------------

LVGL usa patrón observer para eventos:
- Objetos (botones, sliders) son sujetos
- Callbacks son observadores
- Ejemplo:
  lv_obj_add_event_cb(btn, callback, LV_EVENT_CLICKED, NULL);

D) STATE MACHINE
-----------------

La trotadora implementa una máquina de estados:
- Estados: INICIAL, RUNNING, PAUSED, RESUMING, COOLDOWN
- Transiciones: Basadas en eventos de usuario
- ramp_mode_t controla el comportamiento

11.3. DEBUGGING Y LOGGING
--------------------------

A) NIVELES DE LOG
------------------

ESP_LOGE(TAG, "Error: %s", msg);    // Error (siempre mostrado)
ESP_LOGW(TAG, "Warning: %s", msg);  // Advertencia
ESP_LOGI(TAG, "Info: %s", msg);     // Información
ESP_LOGD(TAG, "Debug: %s", msg);    // Debug (solo en build debug)
ESP_LOGV(TAG, "Verbose: %s", msg);  // Verbose (muy detallado)

B) CONFIGURACIÓN DE NIVELES
-----------------------------

En sdkconfig o menuconfig:
Component config → Log output → Default log verbosity

Por tag en runtime:
esp_log_level_set("ui", ESP_LOG_DEBUG);
esp_log_level_set("audio", ESP_LOG_INFO);

C) MONITOR SERIAL
------------------

Para ver logs:
idf.py -p COM_PORT monitor

Comandos útiles:
Ctrl+] : Salir
Ctrl+T Ctrl+H : Ayuda
Ctrl+T Ctrl+R : Reset del chip
Ctrl+T Ctrl+F : Enviar archivo

D) GDBSTUB
-----------

Para debugging con GDB:
1. Habilitar en menuconfig:
   Component config → ESP System Settings → GDB Stub

2. Conectar GDB:
   xtensa-esp32p4-elf-gdb build/lvgl_demo_v8.elf
   (gdb) target remote COM_PORT
   (gdb) bt          # Backtrace
   (gdb) info threads
   (gdb) thread 2
   (gdb) print variable

E) HEAP TRACING
----------------

Para detectar fugas de memoria:

#include "esp_heap_trace.h"

void start_heap_trace() {
    heap_trace_start(HEAP_TRACE_LEAKS);
    // Código a analizar
    heap_trace_stop();
    heap_trace_dump();
}

11.4. PROBLEMAS COMUNES Y SOLUCIONES
-------------------------------------

A) PANTALLA NO ENCIENDE
-------------------------

Síntomas:
- Display negro
- Backlight no funciona

Causas posibles:
1. Cable MIPI-DSI mal conectado
2. Alimentación insuficiente
3. GPIO de backlight incorrecto

Solución:
- Verificar conexiones físicas
- Revisar voltaje de alimentación (debe ser 5V estable)
- Verificar LCD_PWM (GPIO47)
- Revisar logs de BSP:
  I (xxx) ESP32_P4_EV: Display initialized
  I (xxx) ESP32_P4_EV: Setting LCD backlight: 100%

B) TOUCH NO RESPONDE
---------------------

Síntomas:
- Pantalla muestra UI pero no responde al tacto

Causas posibles:
1. Cable de touch mal conectado
2. Driver GSL3680 no inicializado
3. I2C bus ocupado o mal configurado

Solución:
- Verificar conexión FPC del touch
- Revisar logs:
  I (xxx) GT911: TouchPad_ID:0x39,0x31,0x31
  W (xxx) GT911: Unable to initialize the I2C address
- Ejecutar escaneo I2C:
  i2cdetect -y 0
- Verificar calibración en BSP

C) AUDIO NO SUENA
------------------

Síntomas:
- No se escucha beep al presionar botones

Causas posibles:
1. Volumen muy bajo
2. I2S mal configurado
3. Codec ES8311 no inicializado
4. Altavoz desconectado

Solución:
- Aumentar volumen en audio_init():
  bsp_extra_codec_volume_set(70, NULL);
- Verificar pines I2S (GPIO 9-13)
- Revisar logs:
  I (xxx) ES8311: ES8311 in Slave mode
  I (xxx) codec_dev: Codec initialized successfully
- Comprobar amplificador NS4150

D) BOTONES NO FUNCIONAN
------------------------

Síntomas:
- Presionar botones no tiene efecto

Causas posibles:
1. MCP23017 no detectado en I2C
2. Dirección I2C incorrecta
3. Pull-ups no configurados
4. Tarea de botones no creada

Solución:
- Escanear I2C bus:
  i2cdetect -y 0  # Debe mostrar 0x20
- Verificar pull-ups en código:
  mcp23017_write_register(MCP23017_GPPUA, 0xFF);
  mcp23017_write_register(MCP23017_GPPUB, 0xFF);
- Comprobar creación de tarea:
  I (xxx) button_handler: Button handler task created

E) SISTEMA SE REINICIA ALEATORIAMENTE
---------------------------------------

Síntomas:
- Watchdog timeout
- Panic y reset

Causas posibles:
1. Stack overflow en alguna tarea
2. Acceso a memoria inválida
3. División por cero
4. Deadlock en mutex

Solución:
- Revisar stack size de tareas:
  CONFIG_ESP_MAIN_TASK_STACK_SIZE=10240
- Habilitar stack overflow detection:
  Component config → FreeRTOS → Check for stack overflow
- Analizar backtrace en logs:
  Backtrace: 0x4200xxxx:0x3fcyyyyy 0x4200zzzz:0x3fcwwwww
- Usar GDB para debug detallado

F) PERFORMANCE BAJO (LAG EN UI)
--------------------------------

Síntomas:
- UI responde lento
- Animaciones entrecortadas

Causas posibles:
1. CPU sobrecargada
2. Buffer de display insuficiente
3. Demasiados objetos LVGL activos
4. Tarea de alta prioridad bloqueando

Solución:
- Habilitar performance monitor:
  CONFIG_LV_USE_PERF_MONITOR=y
- Aumentar buffer size:
  cfg.buffer_size = BSP_LCD_H_RES * BSP_LCD_V_RES * 2;
- Reducir período de refresh:
  CONFIG_LV_DISP_DEF_REFR_PERIOD=10
- Optimizar código en ui_update_task()
- Revisar distribución de prioridades

11.5. MEJORAS FUTURAS Y TODOs
------------------------------

A) FUNCIONALIDAD
-----------------

□ Conectividad WiFi:
  - Servidor web para control remoto
  - Sincronización de estadísticas con app móvil
  - Actualizaciones OTA

□ Conectividad Bluetooth:
  - Heart rate monitor (monitor de pulso real via BLE)
  - Conexión con apps fitness (Strava, etc.)
  - Control por wearables

□ Almacenamiento:
  - Perfiles de usuario en NVS
  - Historial de entrenamientos en SPIFFS
  - Programas de entrenamiento predefinidos

□ Sensores adicionales:
  - Sensor de pulso real (no simulado)
  - Sensor de cadencia
  - Cálculo real de calorías

□ Control del motor:
  - PWM para controlar motor de velocidad
  - Servo/stepper para controlar inclinación
  - Safety features (parada de emergencia)

B) UI/UX
---------

□ Más pantallas:
  - Pantalla de estadísticas
  - Pantalla de configuración
  - Pantalla de perfiles de usuario
  - Gráficos de progreso

□ Animaciones:
  - Transiciones suaves entre pantallas
  - Indicadores animados de progreso
  - Feedback visual mejorado

□ Temas:
  - Tema claro/oscuro
  - Personalización de colores
  - Tamaños de fuente ajustables

C) TÉCNICO
-----------

□ Optimización:
  - Reducir uso de RAM
  - Mejorar eficiencia energética
  - Acelerar boot time

□ Seguridad:
  - Encriptación de datos personales
  - Autenticación de usuario
  - Secure boot

□ Testing:
  - Unit tests para módulos críticos
  - Integration tests
  - UI testing automatizado

□ Documentación:
  - API reference completa
  - User manual
  - Tutorial de desarrollo

11.6. RECURSOS Y REFERENCIAS
-----------------------------

A) DOCUMENTACIÓN OFICIAL
--------------------------

ESP-IDF:
https://docs.espressif.com/projects/esp-idf/en/latest/

ESP32-P4 Technical Reference:
https://www.espressif.com/sites/default/files/documentation/esp32-p4_technical_reference_manual_en.pdf

ESP32-C6 Technical Reference:
https://www.espressif.com/sites/default/files/documentation/esp32-c6_technical_reference_manual_en.pdf

LVGL Documentation:
https://docs.lvgl.io/8.4/

ESP-Hosted:
https://github.com/espressif/esp-hosted

B) COMPONENTES HARDWARE
-------------------------

JD9365 LCD Driver:
Datasheet en carpeta de documentación de la placa

GSL3680 Touch Controller:
Datasheet proporcionado por fabricante

ES8311 Audio Codec:
https://www.everest-semi.com/

MCP23017 I/O Expander:
https://ww1.microchip.com/downloads/en/devicedoc/20001952c.pdf

C) HERRAMIENTAS
----------------

ESP-IDF VSCode Extension:
https://marketplace.visualstudio.com/items?itemName=espressif.esp-idf-extension

LVGL GUI Guider:
https://www.nxp.com/design/design-center/software/development-software/gui-guider:GUI-GUIDER

esptool (flasher):
https://github.com/espressif/esptool

D) FOROS Y COMUNIDAD
---------------------

ESP32 Forum:
https://esp32.com/

LVGL Forum:
https://forum.lvgl.io/

Stack Overflow [esp32]:
https://stackoverflow.com/questions/tagged/esp32

E) CONTACTO DEL PROYECTO
--------------------------

Desarrollador: [Tu nombre]
Email: [Tu email]
Repositorio: [URL del repo si aplica]

================================================================================
FIN DE LA DOCUMENTACIÓN
================================================================================

Documento generado automáticamente por Claude Code Assistant
Fecha: 2025-10-17
Versión: 1.0

Para más información sobre la integración ESP32-C6, consultar:
c:\esp\Consola_Cinta\README_ESP32C6.md

Para compilar el proyecto:
    cd c:\esp\Consola_Cinta\Plantilla
    idf.py build

Para flashear:
    idf.py -p COM_PORT flash monitor

¡Buena suerte con el desarrollo!
